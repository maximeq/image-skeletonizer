!(function(t, i) {
"object" == typeof exports && "undefined" != typeof module
? (module.exports = i())
: "function" == typeof define && define.amd
? define(i)
: (t.ImageSkeletonizer = i());
})(this, function() {
"use strict";
var t = function(t, i) {
(this.tolerance = void 0 !== i ? i : 12),
(this.width = t.width),
(this.height = t.height),
(this.data = new Uint8Array(t.width * t.height)),
this._buildBinaryImage(t, this.tolerance);
};
(t.prototype.constructor = t),
(t.prototype.getIndex = function(t, i) {
return i * this.width + t;
}),
(t.prototype.getValue = function(t, i) {
return this.data[this.getIndex(t, i)];
}),
(t.prototype._buildBinaryImage = function(t, i) {
for (var e = this.width * this.height, h = 0; h < e; h++) {
var s = 4 * h;
t.data[s] < 125 && t.data[s + 1] < 125 && t.data[s + 2] < 125
? (this.data[h] = 1)
: (this.data[h] = 0);
}
});
var i = t,
e = function(t, e, h, s) {
if (!(h instanceof i))
throw "IntDistanceImage Error : source must be an instance of BinaryImage";
(this.coeff = t),
(this.width = h.width),
(this.height = h.height),
(this.data = new Array(h.width * h.height)),
this._buildDistanceImage(t, e, h, s);
};
(e.prototype.constructor = e),
(e.prototype.rebuild = function(t, i, e, h) {
(this.coeff = t), this._buildDistanceImage(t, i, e, h, this.data);
}),
(e.prototype.getCoeff = function() {
return this.coeff;
}),
(e.prototype.getIndex = function(t, i) {
return i * this.width + t;
}),
(e.prototype.getValue = function(t, i) {
return this.data[this.getIndex(t, i)];
}),
(e.prototype.getIndexValue = function(t) {
return this.data[t];
}),
(e.prototype.getXFromIndex = function(t) {
return t % this.width;
}),
(e.prototype.getYFromIndex = function(t) {
return Math.round(t / this.width);
}),
(e.prototype._buildDistanceImage = function(t, i, e, h) {
const s = e.width,
n = e.height;
for (let t = 0; t < s; ++t) this.data[t] = 0;
for (let o = 1; o < n - 1; ++o) {
this.data[o * s] = 0;
for (let n = 1; n < s - 1; ++n) {
let s = this.getIndex(n, o);
this.data[s] = 0;
let a = 0;
if (e.data[s] != h) {
let e = this.getIndex(n - 1, o - 1),
h = this.getIndex(n, o - 1),
r = this.getIndex(n - 1, o),
d = this.getIndex(n + 1, o - 1);
(a = Math.min(this.data[e] + i, this.data[h] + t)),
(a = Math.min(a, this.data[r] + t)),
(a = Math.min(a, this.data[d] + i)),
(this.data[s] = a);
}
}
this.data[this.getIndex(s - 1, o)] = 0;
}
for (let t = 0; t < s; ++t) this.data[this.getIndex(t, n - 1)] = 0;
for (let o = n - 2; o > 0; --o)
for (let n = s - 2; n > 0; --n) {
let s = this.getIndex(n, o),
a = this.data[s];
if (e.data[s] != h) {
let e = this.getIndex(n + 1, o + 1),
h = this.getIndex(n, o + 1),
r = this.getIndex(n - 1, o + 1),
d = this.getIndex(n + 1, o);
(a = Math.min(a, this.data[e] + i)),
(a = Math.min(a, this.data[h] + t)),
(a = Math.min(a, this.data[r] + i)),
(this.data[s] = Math.min(a, this.data[d] + t));
}
}
}),
(e.prototype.getImageData = function(t) {
var i = new ImageData(this.width, this.height);
let e = 0;
for (let t = 0; t < this.width * this.height; t++)
e = this.data[t] > e ? this.data[t] : e;
for (let t = 0, h = 0, s = 0; t < this.height; t++)
for (let n = 0; n < this.width; n++) {
let o = t * this.width + n;
this.data[o] > 3
? ((s = (255 * this.data[o]) / e),
  (i.data[h] = s),
  (i.data[h + 1] = s),
  (i.data[h + 2] = s),
  (i.data[h + 3] = 255))
: ((i.data[h] = 255),
  (i.data[h + 1] = 255),
  (i.data[h + 2] = 255),
  (i.data[h + 3] = 255)),
(h += 4);
}
return i;
});
var h = e,
s = function(t, i, e, h) {
(this.width = t.width),
(this.height = t.height),
(this.data = new Array(this.width * this.height));
for (let e = 0; e < this.width * this.height; e++)
t.data[e] != i ? (this.data[e] = 1) : (this.data[e] = 0);
let s = 0;
for (let t = 0; t < h.width * h.height; t++) s = h.data[t] > s ? h.data[t] : s;
this.CleanBorderPixels(),
this.skeletonizeEckhardtMaderlechner93(e, h, 0.8 * s),
this.CleanBorderPixels(),
this.thin();
};
(s.prototype.constructor = s),
(s.prototype.getImageData = function(t, i) {
var e = new ImageData(this.width, this.height),
h = t || [255, 255, 255, 255],
s = i || [255, 0, 0, 255];
let n = 0;
for (let t = 0; t < this.width * this.height; t++)
n = this.data[t] > n ? this.data[t] : n;
for (let t = 0, i = 0; t < this.height; t++)
for (let n = 0; n < this.width; n++) {
let o = t * this.width + n;
1 === this.data[o]
? ((e.data[i] = s[0]),
  (e.data[i + 1] = s[1]),
  (e.data[i + 2] = s[2]),
  (e.data[i + 3] = s[3]))
: ((e.data[i] = h[0]),
  (e.data[i + 1] = h[1]),
  (e.data[i + 2] = h[2]),
  (e.data[i + 3] = h[3])),
(i += 4);
}
return e;
}),
(s.prototype.CleanBorderPixels = function() {
for (let t = 0; t < this.width; t++)
(this.data[t] = 0), (this.data[(this.height - 1) * this.width + t] = 0);
for (let t = 1; t < this.height - 2; t++)
(this.data[t * this.width] = 0),
(this.data[t * this.width + (this.width - 1)] = 0);
}),
(s.prototype.thin = function() {
let t = this.width - 2;
for (let i = 1; i < this.height - 1; i++) {
t += 2;
for (let i = 1; i < this.width - 1; i++) {
if ((t++, 0 == (1 & this.data[t]))) continue;
const i = this.getCurrentNeighborhood(t);
((0 == (7 & i) && 112 == (112 & i)) ||
(0 == (14 & i) && 160 == (160 & i)) ||
(0 == (28 & i) && 193 == (193 & i)) ||
(0 == (56 & i) && 130 == (130 & i)) ||
(0 == (112 & i) && 7 == (7 & i)) ||
(0 == (224 & i) && 10 == (10 & i)) ||
(0 == (193 & i) && 28 == (28 & i)) ||
(0 == (131 & i) && 40 == (40 & i))) &&
(this.data[t] = 0);
}
}
return this.data;
}),
(s.prototype.skeletonizeEckhardtMaderlechner93 = function(t, i, e) {
const h = this.width * this.height,
s = new Array(this.width * this.height),
n = new Array(this.width * this.height),
o = new Array(this.width * this.height),
a = new Array(this.width * this.height),
r = new Array(this.width * this.height),
d = new Array(this.width * this.height),
g = new Array(this.width * this.height),
f = new Array(this.width * this.height);
let u = !0,
y = 0;
const w = this.width + 1,
c = h - this.width - 1;
for (; u && y < t; ) {
u = !1;
for (let t = w; t < c; t++)
(n[t] = this.getNbStrongNeighbors(this.data, t)),
(o[t] = n[t] + this.getNbNoStrongNeighbors(this.data, t)),
this.data[t]
? 4 == n[t]
  ? ((s[t] = 2), (f[t] = 1))
  : ((s[t] = 1), (f[t] = 2))
: (s[t] = 0);
for (let t = w; t < c; t++)
this.data[t]
? (a[t] =
  1 == s[t] &&
  (2 == s[t + 1] ||
  2 == s[t - 1] ||
  2 == s[t + this.width] ||
  2 == s[t - this.width]))
: (a[t] = !1),
a[t] ? ((a[t] = 1), (f[t] = 3)) : (a[t] = 0);
for (let t = w; t < c; ++t) {
if (this.data[t] && 1 == s[t]) {
let i = 0 != (1 & this.data[t + 1]),
e = 0 != (1 & this.data[t - this.width + 1]),
h = 0 != (1 & this.data[t - this.width]),
n = 0 != (1 & this.data[t - this.width - 1]),
o = 0 != (1 & this.data[t - 1]),
a = 0 != (1 & this.data[t + this.width - 1]),
r = 0 != (1 & this.data[t + this.width]),
g = 0 != (1 & this.data[t + this.width + 1]);
const f =
(1 - i) * e +
(1 - e) * h +
(1 - h) * n +
(1 - n) * o +
(1 - o) * a +
(1 - a) * r +
(1 - r) * g +
(1 - g) * i,
u = i + e + h + n + o + a + r + g,
y = 1 == f || (0 == f && 8 == u);
d[t] = 1 == s[t] && y && (i || h || o || r);
} else d[t] = !1;
d[t] && (f[t] = 4);
}
for (let t = w; t < c; ++t) {
if (this.data[t]) {
const i = 2 == s[t + 1] && !this.data[t - 1],
e = 2 == s[t - 1] && !this.data[t + 1],
h = 2 == s[t + this.width] && !this.data[t - this.width],
n = 2 == s[t - this.width] && !this.data[t + this.width];
r[t] = a[t] && (i || e || h || n);
} else r[t] = !1;
r[t] && (f[t] = 5);
}
for (let t = 0; t < h; ++t)
this.data[t]
? d[t] && r[t]
  ? ((g[t] = 0), (f[t] = 6), (u = !0))
  : 0 == o[t]
  ? (g[t] = 0)
  : i.data[t] < e && 1 == o[t]
  ? ((g[t] = 0), (u = !0))
  : (g[t] = 1)
: ((g[t] = 0), (f[t] = 0));
for (let t = 0; t < g.length; t++) this.data[t] = g[t];
++y;
}
}),
(s.prototype.getCurrentNeighborhood = function(t) {
var i = this.data;
return (
((1 & i[t - 1]) << 7) |
((1 & i[t + 1]) << 3) |
((1 & i[t + this.width]) << 5) |
((1 & i[t - this.width]) << 1) |
(1 & i[t - (this.width + 1)]) |
((1 & i[t - (this.width - 1)]) << 2) |
((1 & i[t + (this.width - 1)]) << 6) |
((1 & i[t + (this.width + 1)]) << 4)
);
}),
(s.prototype.nbNeighbours = function(t) {
return (
(1 & t) +
((t >> 1) & 1) +
((t >> 2) & 1) +
((t >> 3) & 1) +
((t >> 4) & 1) +
((t >> 5) & 1) +
((t >> 6) & 1) +
((t >> 7) & 1)
);
}),
(s.prototype.getNbStrongNeighbors = function(t, i) {
return t[i - 1] + t[i + 1] + t[i - this.width] + t[i + this.width];
}),
(s.prototype.getNbNoStrongNeighbors = function(t, i) {
return (
t[i - 1 - this.width] +
t[i - 1 + this.width] +
t[i + 1 - this.width] +
t[i + 1 + this.width]
);
}),
(s.prototype.isInnerBoundaryPixel = function(t, i) {
return (
(1 == t[i] && 2 == t[i - 1]) ||
2 == t[i + 1] ||
2 == t[i - this.width] ||
2 == t[i + this.width]
);
}),
(s.prototype.isSimpleBoundaryPixel = function(t, i) {
let e = 0 != (1 & t[i + 1]),
h = 0 != (1 & t[i - this.width + 1]),
s = 0 != (1 & t[i - this.width]),
n = 0 != (1 & t[i - this.width - 1]),
o = 0 != (1 & t[i - 1]),
a = 0 != (1 & t[i + this.width - 1]),
r = 0 != (1 & t[i + this.width]),
d = 0 != (1 & t[i + this.width + 1]);
const g =
(1 - e) * h +
(1 - h) * s +
(1 - s) * n +
(1 - n) * o +
(1 - o) * a +
(1 - a) * r +
(1 - r) * d +
(1 - d) * e;
return (
(1 == g || (0 == g && 8 == e + h + s + n + o + a + r + d)) && (e || s || o || r)
);
});
var n = s,
o = function(t, i, e) {
(this.position = t), (this.weight = i), (this.neighbors = e || new Map());
};
(o.prototype.constructor = o),
(o.prototype.getPosition = function() {
return this.position;
}),
(o.prototype.getWeight = function() {
return this.weight;
}),
(o.prototype.getNeighbors = function() {
return this.neighbors;
}),
(o.prototype.setPosition = function(t) {
this.position = t;
}),
(o.prototype.setWeight = function(t) {
this.weight = t;
}),
(o.prototype.setNeighbors = function(t) {
this.neighbors = t;
});
var a = o,
r = function(t, i) {
(this.x = t), (this.y = i);
};
(r.prototype.distanceToOrigin = function(t) {
var i = this.x,
e = this.y;
return Math.sqrt(i * i + e * e);
}),
(r.prototype.distanceTo = function(t) {
var i = this.x - t.x,
e = this.y - t.y;
return Math.sqrt(i * i + e * e);
}),
(r.prototype.barycenter = function(t, i, e, h) {
var s = h / (e + h);
return (
(this.x = (1 - s) * t.x + s * i.x), (this.y = (1 - s) * t.y + s * i.y), this
);
});
var d = r,
g = function(t, i) {
(this.x = t || 0), (this.y = i || 0);
};
(g.prototype.length = function(t) {
var i = this.x,
e = this.y;
return Math.sqrt(i * i + e * e);
}),
(g.prototype.subPoints = function(t, i) {
t.x, i.x, t.yp2.y;
return this;
});
var f = g,
u = function(t, i) {
(this.skelImg = t), (this.distImg = i);
};
(u.prototype.constructor = u),
(u.prototype.buildHierarchy = function() {
const t = this.skelImg.width * this.skelImg.height;
let i = {},
e = [],
h = this._findNextPixelWithNeighbors(this.skelImg, this.distImg, 0);
for (; h < t; ) {
if (void 0 === i[h]) {
const t = h % this.skelImg.width,
s = Math.round(h / this.skelImg.width);
(i[h] = new a(
new d(t + 0.5, s + 0.5),
this.distImg.data[h] / this.distImg.getCoeff()
)),
e.push(i[h]),
this._recHierarchy(i[h], h, i);
}
h = this._findNextPixelWithNeighbors(h + 1);
}
return e;
}),
(u.prototype._simplifyHierarchy = function(t, i, e) {
var h = t.position();
if (1 === t.getNeighbors().size()) {
var s = t
.getNeighbors()
.keys()
.next()
.value.position();
new f().subPoints(s, h);
}
}),
(u.prototype._findNextPixelWithNeighbors = function(t) {
const i = this.skelImg.width * this.skelImg.height;
let e = t;
for (e = t; e < i; e++)
if (1 & this.skelImg.data[e]) {
if (0 != this.skelImg.getCurrentNeighborhood(e)) break;
this.skelImg.data[e] = 0;
}
return e;
}),
(u.prototype._addNeighbors = function(t, i, e, h) {
const s = this.skelImg.width,
n = e % s,
o = Math.round(e / s);
let r = 0;
if (1 & i) {
if (void 0 === h[e - s - 1]) {
const t = new a(
new d(n - 1 + 0.5, o - 1 + 0.5),
this.distImg.getIndexValue(e - s - 1)
);
(h[e - s - 1] = t), r++;
}
t.neighbors.set(e - s - 1, h[e - s - 1]);
}
if (2 & i) {
if (void 0 === h[e - s]) {
const t = new a(new d(n + 0.5, o - 1 + 0.5), this.distImg.getIndexValue(e - s));
(h[e - s] = t), r++;
}
t.neighbors.set(e - s, h[e - s]);
}
if (4 & i) {
if (void 0 === h[e - s + 1]) {
const t = new a(
new d(n + 1 + 0.5, o - 1 + 0.5),
this.distImg.getIndexValue(e - s + 1)
);
(h[e - s + 1] = t), r++;
}
t.neighbors.set(e - s + 1, h[e - s + 1]);
}
if (8 & i) {
if (void 0 === h[e + 1]) {
const t = new a(new d(n + 1 + 0.5, o + 0.5), this.distImg.getIndexValue(e + 1));
(h[e + 1] = t), r++;
}
t.neighbors.set(e + 1, h[e + 1]);
}
if (16 & i) {
if (void 0 === h[e + s + 1]) {
const t = new a(
new d(n + 1 + 0.5, o + 1 + 0.5),
this.distImg.getIndexValue(e + s + 1)
);
(h[e + s + 1] = t), r++;
}
t.neighbors.set(e + s + 1, h[e + s + 1]);
}
if (32 & i) {
if (void 0 === h[e + s]) {
const t = new a(new d(n + 0.5, o + 1 + 0.5), this.distImg.getIndexValue(e + s));
(h[e + s] = t), r++;
}
t.neighbors.set(e + s, h[e + s]);
}
if (64 & i) {
if (void 0 === h[e + s - 1]) {
const t = new a(
new d(n - 1 + 0.5, o + 1 + 0.5),
this.distImg.getIndexValue(e + s - 1)
);
(h[e + s - 1] = t), r++;
}
t.neighbors.set(e + s - 1, h[e + s - 1]);
}
if (128 & i) {
if (void 0 === h[e - 1]) {
const t = new a(new d(n - 1 + 0.5, o + 0.5), this.distImg.getIndexValue(e - 1));
(h[e - 1] = t), r++;
}
t.neighbors.set(e - 1, h[e - 1]);
}
return r;
}),
(u.prototype._recHierarchy = function(t, i, e) {
const h = this.skelImg.getCurrentNeighborhood(i);
if (this._addNeighbors(t, h, i, e))
for (let [i, h] of t.getNeighbors()) this._recHierarchy(h, i, e);
});
var y = u,
w = function(t, i, e, h, s) {
var n = new d(i.x - t.x, i.y - t.y),
o = n.distanceToOrigin();
(n.x = n.x / o), (n.y = n.y / o);
var a = new d(s.x - t.x, s.y - t.y),
r = a.distanceToOrigin(),
g = r * r,
f = a.x * n.x + a.y * n.y,
u = (f + (-Math.sqrt(Math.max(0, g - f * f)) / o) * (e - h)) / o;
u > 1 && (u = 1), u < 0 && (u = 0);
var y = new d(t.x, t.y);
return (
(y.x += (i.x - y.x) * u),
(y.y += (i.y - y.y) * u),
(y.z += (i.z - y.z) * u),
(a.x = s.x - y.x),
(a.y = s.y - y.y),
a.distanceToOrigin() - (u * h + (1 - u) * e)
);
},
c = function(t) {
this.distImg = t;
};
(c.prototype.constructor = c),
(c.prototype.buildHierarchy = function() {
var t = this;
const i = this.distImg.width,
e = this.distImg.height;
for (var h = {}, s = {}, n = [], o = new Array(i * e), r = 0; r < o.length; ++r)
o[r] = !1;
for (
var g = function(e, h, s) {
for (
var n = e.position.x,
a = e.position.y,
r = e.getPosition(),
g = Math.ceil(e.weight),
f = h ? Math.ceil(h.getWeight()) : 0,
u = h ? h.getPosition() : null,
y = new d(0, 0),
c = {
min: {
x: h ? Math.min(r.x - g, u.x - f) : r.x - g,
y: h ? Math.min(r.y - g, u.y - f) : r.y - g
},
max: {
x: h ? Math.max(r.x + g, u.x + f) : r.x + g,
y: h ? Math.max(r.y + g, u.y + f) : r.y + g
}
},
p = c.min.x;
p < c.max.x;
p++
)
for (var l = c.min.y; l < c.max.y; l++) {
(y.x = p), (y.y = l);
var x = h
? w(e.getPosition(), h.getPosition(), g, Math.ceil(h.weight), y)
: (p - n) * (p - n) + (l - a) * (l - a);
if (h ? x <= 0 : x <= g * g) (o[(M = l * i + p)] = !0), delete s[M];
}
for (
var I = 2 * Math.PI * (e.weight + 1), m = Math.round(I), v = 0;
v < m;
++v
) {
var b = (2 * v * Math.PI) / m,
M = ((p = Math.round(e.position.x + Math.cos(b) * (e.weight + 1))),
(l = Math.round(e.position.y + Math.sin(b) * (e.weight + 1))) * i + p),
k = t.distImg.getValue(p, l) / t.distImg.getCoeff();
!o[M] && k > 3 && (s[M] = e);
}
},
f = 0,
u = -1,
y = -1,
c = 0;
c < i;
++c
)
for (var p = 0; p < e; ++p) {
var l = this.distImg.getValue(c, p);
l > f && ((f = l), (u = c), (y = p));
}
var x = new a(new d(u, y), f / this.distImg.getCoeff());
(s[this.distImg.getIndex(u, y)] = x), n.push(x), g(x, null, h);
for (var I = 0, m = Object.keys(h); 0 !== m.length && I < 1e4; ) {
var v = -1,
b = 0;
for (r = 0; r < m.length; ++r) {
var M = parseInt(m[r]);
o[M]
? delete h[m[r]]
: this.distImg.getIndexValue(M) > b &&
  ((b = this.distImg.getIndexValue(M)), (v = M));
}
b /= this.distImg.getCoeff();
var k = new d(this.distImg.getXFromIndex(v), this.distImg.getYFromIndex(v)),
N = h[v],
P = {v: b, p: new d(k.x, k.y), idx: v};
(function() {
var i = N.getPosition().distanceTo(k),
e = new d(0, 0);
e.barycenter(k, N.getPosition(), 0.5, 0.5),
(e.x = Math.round(e.x)),
(e.y = Math.round(e.y));
var h = t.distImg.getValue(e.x, e.y) / t.distImg.getCoeff(),
s = new d(0, 0),
n = new d(k.x - N.getPosition().x, k.y - N.getPosition().y);
(n.x /= i), (n.y /= i);
for (
var o = new d(-n.y, n.x),
a = {v: h, p: new d(e.x, e.y), idx: v},
r = Math.max(N.getWeight() / 2, 3),
g = -r;
g <= r;
g++
) {
(s.x = Math.round(e.x + g * o.x)), (s.y = Math.round(e.y + g * o.y));
var f = t.distImg.getValue(s.x, s.y) / t.distImg.getCoeff();
f > a.v && f > h + 1.5 && ((a.v = f), (a.p.x = s.x), (a.p.y = s.y));
}
return (
(a.p.x !== e.x || a.p.y !== e.y) &&
((P.v = a.v),
(P.p.x = a.p.x),
(P.p.y = a.p.y),
(P.idx = t.distImg.getIndex(a.p.x, a.p.y)),
!0)
);
})() ||
(function() {
for (
var i = N.getPosition().distanceTo(k), e = new d(0, 0), h = 1;
h < i;
h += 1
) {
var s = h / i;
e.barycenter(k, N.getPosition(), 1 - s, s),
(e.x = Math.round(e.x)),
(e.y = Math.round(e.y));
var n = t.distImg.getValue(e.x, e.y) / t.distImg.getCoeff(),
o = h + b - n,
a = (1 - s) * b + s * N.weight;
o < 1 &&
n > a &&
((P.v = n),
(P.p.x = e.x),
(P.p.y = e.y),
(P.idx = t.distImg.getIndex(e.x, e.y)));
}
})();
var C = new a(P.p, P.v);
C.neighbors.set(this.distImg.getIndex(N.position.x, N.position.y), N),
N.neighbors.set(this.distImg.getIndex(C.position.x, C.position.y), C),
(s[P.idx] = C),
n.push(C),
delete h[v],
delete h[P.idx],
g(C, N, h),
(m = Object.keys(h)),
I++;
}
return {hierarchy: n, covered: o};
});
var p = c,
l = {};
return (
(l.BinaryImage = i),
(l.IntDistanceImage = h),
(l.SkeletonImage = n),
(l.Skeletonizer = y),
(l.skeletonize = function(t) {
var e = new i(t),
s = new h(3, 4, e, 0),
o = new n(e, 0, 2e3, s);
return {
skeleton: new y(o, s).buildHierarchy(),
binaryImg: e,
distImg: s,
skelImg: o
};
}),
(l.skeletonizeQ = function(t) {
var e = new i(t),
s = new h(3, 4, e, 0),
n = new p(s).buildHierarchy();
return {skeleton: n.hierarchy, binaryImg: e, distImg: s, covered: n.covered};
}),
(l.drawHierarchyInImageData = function(t, i) {
for (
var e = i,
h = {},
s = [],
n = function(t) {
var i = t.position.x + ";" + t.position.y;
void 0 === h[i] &&
((h[i] = t),
s.push(t),
t.getNeighbors().forEach(function(t, i, e) {
n(t);
}));
},
o = 0;
o < t.length;
++o
)
n(t[o]);
for (var a = 0; a < e.width; ++a)
for (var r = 0; r < e.height; ++r) {
var d = 0;
for (o = 0; o < s.length; ++o) {
var g = s[o].position.x + 0.5,
f = s[o].position.y + 0.5;
(a + 0.5 - g) * (a + 0.5 - g) + (r + 0.5 - f) * (r + 0.5 - f) <=
s[o].weight * s[o].weight && d++;
}
var u = 4 * (r * e.width + a);
e.data[u + 1] = (e.data[u + 1] + 255 * d) / (d + 1);
}
for (o = 0; o < s.length; ++o) {
var y = s[o];
u = 4 * (y.position.y * e.width + y.position.x);
(e.data[u] = 255), (e.data[u + 1] = 0), (e.data[u + 2] = 0);
}
return e;
}),
(l.drawCoverInImageData = function(t, i) {
for (var e = i, h = 0; h < e.width; ++h)
for (var s = 0; s < e.height; ++s) {
var n = s * e.width + h;
t[n] && ((n *= 4), (e.data[n + 1] = (e.data[n + 1] + 255) / 2));
}
return e;
}),
(l.drawHierarchyInCanvas = function(t, i) {
for (
var e = i.getContext("2d"),
h = {},
s = [],
n = function(t) {
var i = t.position.x + ";" + t.position.y;
void 0 === h[i] &&
((h[i] = t),
s.push(t),
t.getNeighbors().forEach(function(t, i, e) {
n(t);
}));
},
o = 0;
o < t.length;
++o
)
n(t[o]);
for (o = 0; o < s.length; ++o) {
var a = s[o];
a.getNeighbors().forEach(function(t, i, h) {
(e.lineWidth = 1),
(e.strokeStyle = "#ff0000"),
e.beginPath(),
e.moveTo(a.position.x, a.position.y),
e.lineTo(t.position.x, t.position.y),
e.stroke(),
(e.fillStyle = "#0000ff"),
e.fillRect(a.position.x, a.position.y, 1, 1),
e.fillRect(t.position.x, t.position.y, 1, 1);
});
}
}),
l
);
});
