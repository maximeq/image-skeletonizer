!(function(t, i) {
"object" == typeof exports && "undefined" != typeof module
? (module.exports = i())
: "function" == typeof define && define.amd
? define(i)
: (t.ImageSkeletonizer = i());
})(this, function() {
"use strict";
var t = function(t, i) {
(this.tolerance = void 0 !== i ? i : 12),
(this.width = t.width),
(this.height = t.height),
(this.data = new Uint8Array(t.width * t.height)),
this._buildBinaryImage(t, this.tolerance);
};
(t.prototype.constructor = t),
(t.prototype.getIndex = function(t, i) {
return i * this.width + t;
}),
(t.prototype.getValue = function(t, i) {
return this.data[this.getIndex(t, i)];
}),
(t.prototype._buildBinaryImage = function(t, i) {
for (var h = this.width * this.height, e = 0; e < h; e++) {
var s = 4 * e;
t.data[s] < 125 && t.data[s + 1] < 125 && t.data[s + 2] < 125
? (this.data[e] = 1)
: (this.data[e] = 0);
}
});
var i = t,
h = function(t, h, e, s) {
if (!(e instanceof i))
throw "IntDistanceImage Error : source must be an instance of BinaryImage";
(this.coeff = t),
(this.width = e.width),
(this.height = e.height),
(this.data = new Array(e.width * e.height)),
this._buildDistanceImage(t, h, e, s);
};
(h.prototype.constructor = h),
(h.prototype.rebuild = function(t, i, h, e) {
(this.coeff = t), this._buildDistanceImage(t, i, h, e, this.data);
}),
(h.prototype.getCoeff = function() {
return this.coeff;
}),
(h.prototype.getIndex = function(t, i) {
return i * this.width + t;
}),
(h.prototype.getValue = function(t, i) {
return this.data[this.getIndex(t, i)];
}),
(h.prototype._buildDistanceImage = function(t, i, h, e) {
const s = h.width,
a = h.height;
for (let t = 0; t < s; ++t) this.data[t] = 0;
for (let n = 1; n < a - 1; ++n) {
this.data[n * s] = 0;
for (let a = 1; a < s - 1; ++a) {
let s = this.getIndex(a, n);
this.data[s] = 0;
let o = 0;
if (h.data[s] != e) {
let h = this.getIndex(a - 1, n - 1),
e = this.getIndex(a, n - 1),
r = this.getIndex(a - 1, n),
d = this.getIndex(a + 1, n - 1);
(o = Math.min(this.data[h] + i, this.data[e] + t)),
(o = Math.min(o, this.data[r] + t)),
(o = Math.min(o, this.data[d] + i)),
(this.data[s] = o);
}
}
this.data[this.getIndex(s - 1, n)] = 0;
}
for (let t = 0; t < s; ++t) this.data[this.getIndex(t, a - 1)] = 0;
for (let n = a - 2; n > 0; --n)
for (let a = s - 2; a > 0; --a) {
let s = this.getIndex(a, n),
o = this.data[s];
if (h.data[s] != e) {
let h = this.getIndex(a + 1, n + 1),
e = this.getIndex(a, n + 1),
r = this.getIndex(a - 1, n + 1),
d = this.getIndex(a + 1, n);
(o = Math.min(o, this.data[h] + i)),
(o = Math.min(o, this.data[e] + t)),
(o = Math.min(o, this.data[r] + i)),
(this.data[s] = Math.min(o, this.data[d] + t));
}
}
}),
(h.prototype.getImageData = function(t) {
var i = new ImageData(this.width, this.height);
let h = 0;
for (let t = 0; t < this.width * this.height; t++)
h = this.data[t] > h ? this.data[t] : h;
for (let t = 0, e = 0, s = 0; t < this.height; t++)
for (let a = 0; a < this.width; a++) {
let n = t * this.width + a;
this.data[n] > 3
? ((s = (255 * this.data[n]) / h),
  (i.data[e] = s),
  (i.data[e + 1] = s),
  (i.data[e + 2] = s),
  (i.data[e + 3] = 255))
: ((i.data[e] = 255),
  (i.data[e + 1] = 255),
  (i.data[e + 2] = 255),
  (i.data[e + 3] = 255)),
(e += 4);
}
return i;
});
var e = h,
s = function(t, i, h, e) {
(this.width = t.width),
(this.height = t.height),
(this.data = new Array(this.width * this.height));
for (let h = 0; h < this.width * this.height; h++)
t.data[h] != i ? (this.data[h] = 1) : (this.data[h] = 0);
let s = 0;
for (let t = 0; t < e.width * e.height; t++) s = e.data[t] > s ? e.data[t] : s;
this.CleanBorderPixels(),
this.skeletonizeEckhardtMaderlechner93(h, e, 0.8 * s),
this.CleanBorderPixels(),
this.thin();
};
(s.prototype.constructor = s),
(s.prototype.getImageData = function(t, i) {
var h = new ImageData(this.width, this.height),
e = t || [255, 255, 255, 255],
s = i || [255, 0, 0, 255];
let a = 0;
for (let t = 0; t < this.width * this.height; t++)
a = this.data[t] > a ? this.data[t] : a;
for (let t = 0, i = 0; t < this.height; t++)
for (let a = 0; a < this.width; a++) {
let n = t * this.width + a;
1 === this.data[n]
? ((h.data[i] = s[0]),
  (h.data[i + 1] = s[1]),
  (h.data[i + 2] = s[2]),
  (h.data[i + 3] = s[3]))
: ((h.data[i] = e[0]),
  (h.data[i + 1] = e[1]),
  (h.data[i + 2] = e[2]),
  (h.data[i + 3] = e[3])),
(i += 4);
}
return h;
}),
(s.prototype.CleanBorderPixels = function() {
for (let t = 0; t < this.width; t++)
(this.data[t] = 0), (this.data[(this.height - 1) * this.width + t] = 0);
for (let t = 1; t < this.height - 2; t++)
(this.data[t * this.width] = 0),
(this.data[t * this.width + (this.width - 1)] = 0);
}),
(s.prototype.thin = function() {
let t = this.width - 2;
for (let i = 1; i < this.height - 1; i++) {
t += 2;
for (let i = 1; i < this.width - 1; i++) {
if ((t++, 0 == (1 & this.data[t]))) continue;
const i = this.getCurrentNeighborhood(this.data, t);
((0 == (7 & i) && 112 == (112 & i)) ||
(0 == (14 & i) && 160 == (160 & i)) ||
(0 == (28 & i) && 193 == (193 & i)) ||
(0 == (56 & i) && 130 == (130 & i)) ||
(0 == (112 & i) && 7 == (7 & i)) ||
(0 == (224 & i) && 10 == (10 & i)) ||
(0 == (193 & i) && 28 == (28 & i)) ||
(0 == (131 & i) && 40 == (40 & i))) &&
(this.data[t] = 0);
}
}
return this.data;
}),
(s.prototype.skeletonizeEckhardtMaderlechner93 = function(t, i, h) {
const e = this.width * this.height,
s = new Array(this.width * this.height),
a = new Array(this.width * this.height),
n = new Array(this.width * this.height),
o = new Array(this.width * this.height),
r = new Array(this.width * this.height),
d = new Array(this.width * this.height),
g = new Array(this.width * this.height),
w = new Array(this.width * this.height);
let f = !0,
c = 0;
const u = this.width + 1,
p = e - this.width - 1;
for (; f && c < t; ) {
f = !1;
for (let t = u; t < p; t++)
(a[t] = this.getNbStrongNeighbors(this.data, t)),
(n[t] = a[t] + this.getNbNoStrongNeighbors(this.data, t)),
this.data[t]
? 4 == a[t]
  ? ((s[t] = 2), (w[t] = 1))
  : ((s[t] = 1), (w[t] = 2))
: (s[t] = 0);
for (let t = u; t < p; t++)
this.data[t]
? (o[t] =
  1 == s[t] &&
  (2 == s[t + 1] ||
  2 == s[t - 1] ||
  2 == s[t + this.width] ||
  2 == s[t - this.width]))
: (o[t] = !1),
o[t] ? ((o[t] = 1), (w[t] = 3)) : (o[t] = 0);
for (let t = u; t < p; ++t) {
if (this.data[t] && 1 == s[t]) {
let i = 0 != (1 & this.data[t + 1]),
h = 0 != (1 & this.data[t - this.width + 1]),
e = 0 != (1 & this.data[t - this.width]),
a = 0 != (1 & this.data[t - this.width - 1]),
n = 0 != (1 & this.data[t - 1]),
o = 0 != (1 & this.data[t + this.width - 1]),
r = 0 != (1 & this.data[t + this.width]),
g = 0 != (1 & this.data[t + this.width + 1]);
const w =
(1 - i) * h +
(1 - h) * e +
(1 - e) * a +
(1 - a) * n +
(1 - n) * o +
(1 - o) * r +
(1 - r) * g +
(1 - g) * i,
f = i + h + e + a + n + o + r + g,
c = 1 == w || (0 == w && 8 == f);
d[t] = 1 == s[t] && c && (i || e || n || r);
} else d[t] = !1;
d[t] && (w[t] = 4);
}
for (let t = u; t < p; ++t) {
if (this.data[t]) {
const i = 2 == s[t + 1] && !this.data[t - 1],
h = 2 == s[t - 1] && !this.data[t + 1],
e = 2 == s[t + this.width] && !this.data[t - this.width],
a = 2 == s[t - this.width] && !this.data[t + this.width];
r[t] = o[t] && (i || h || e || a);
} else r[t] = !1;
r[t] && (w[t] = 5);
}
for (let t = 0; t < e; ++t)
this.data[t]
? d[t] && r[t]
  ? ((g[t] = 0), (w[t] = 6), (f = !0))
  : 0 == n[t]
  ? (g[t] = 0)
  : i.data[t] < h && 1 == n[t]
  ? ((g[t] = 0), (f = !0))
  : (g[t] = 1)
: ((g[t] = 0), (w[t] = 0));
for (let t = 0; t < g.length; t++) this.data[t] = g[t];
++c;
}
}),
(s.prototype.getCurrentNeighborhood = function(t, i) {
return (
((1 & t[i - 1]) << 7) |
((1 & t[i + 1]) << 3) |
((1 & t[i + this.width]) << 5) |
((1 & t[i - this.width]) << 1) |
(1 & t[i - (this.width + 1)]) |
((1 & t[i - (this.width - 1)]) << 2) |
((1 & t[i + (this.width - 1)]) << 6) |
((1 & t[i + (this.width + 1)]) << 4)
);
}),
(s.prototype.nbNeighbours = function(t) {
return (
(1 & t) +
((t >> 1) & 1) +
((t >> 2) & 1) +
((t >> 3) & 1) +
((t >> 4) & 1) +
((t >> 5) & 1) +
((t >> 6) & 1) +
((t >> 7) & 1)
);
}),
(s.prototype.getNbStrongNeighbors = function(t, i) {
return t[i - 1] + t[i + 1] + t[i - this.width] + t[i + this.width];
}),
(s.prototype.getNbNoStrongNeighbors = function(t, i) {
return (
t[i - 1 - this.width] +
t[i - 1 + this.width] +
t[i + 1 - this.width] +
t[i + 1 + this.width]
);
}),
(s.prototype.isInnerBoundaryPixel = function(t, i) {
return (
(1 == t[i] && 2 == t[i - 1]) ||
2 == t[i + 1] ||
2 == t[i - this.width] ||
2 == t[i + this.width]
);
}),
(s.prototype.isSimpleBoundaryPixel = function(t, i) {
let h = 0 != (1 & t[i + 1]),
e = 0 != (1 & t[i - this.width + 1]),
s = 0 != (1 & t[i - this.width]),
a = 0 != (1 & t[i - this.width - 1]),
n = 0 != (1 & t[i - 1]),
o = 0 != (1 & t[i + this.width - 1]),
r = 0 != (1 & t[i + this.width]),
d = 0 != (1 & t[i + this.width + 1]);
const g =
(1 - h) * e +
(1 - e) * s +
(1 - s) * a +
(1 - a) * n +
(1 - n) * o +
(1 - o) * r +
(1 - r) * d +
(1 - d) * h;
return (
(1 == g || (0 == g && 8 == h + e + s + a + n + o + r + d)) && (h || s || n || r)
);
});
var a = s,
n = function(t, i, h) {
(this.position = t), (this.weight = i), (this.neighbors = h);
};
(n.prototype.constructor = n),
(n.prototype.getPosition = function() {
return this.position;
}),
(n.prototype.getWeight = function() {
return this.weight;
}),
(n.prototype.getNeighbors = function() {
return this.neighbors;
}),
(n.prototype.setPosition = function(t) {
this.position = t;
}),
(n.prototype.setWeight = function(t) {
this.weight = t;
}),
(n.prototype.setNeighbors = function(t) {
this.neighbors = t;
});
var o = n,
r = function(t, i) {
(this.x = t), (this.y = i);
},
d = function(t, i) {
(this.skelImg = t), (this.distImg = i);
};
(d.prototype.constructor = d),
(d.prototype.buildHierarchy = function() {
const t = this.skelImg.width * this.skelImg.height;
let i,
h = new Array(t),
e = this._findFirstPixelWithNeighbors(this.skelImg, this.distImg, h);
if (e < t) {
const t = e % this.skelImg.width,
s = Math.round(e / this.skelImg.width);
(i = new o(new r(t + 0.5, s + 0.5), this.distImg.data[e], new Map())),
(h[e] = i),
this._recHierarchy(i, e, this.skelImg, this.distImg, h);
}
return console.log(i), i;
}),
(d.prototype._findFirstPixelWithNeighbors = function(t, i, h) {
const e = t.width * t.height;
let s;
for (s = 0; s < e; s++)
if (1 & t.data[s]) {
if (0 != t.getCurrentNeighborhood(t.data, s)) break;
t.data[s] = 0;
}
return s;
}),
(d.prototype._addNeighbors = function(t, i, h, e, s, a) {
const n = h % e,
d = Math.round(h / e);
let g = 0;
if (1 & i) {
if (!a[h - e - 1]) {
const t = new o(new r(n - 1 + 0.5, d - 1 + 0.5), s[h - e - 1], new Map());
(a[h - e - 1] = t), g++;
}
t.neighbors.set(h - e - 1, a[h - e - 1]);
}
if (2 & i) {
if (!a[h - e]) {
const t = new o(new r(n + 0.5, d - 1 + 0.5), s[h - e], new Map());
(a[h - e] = t), g++;
}
t.neighbors.set(h - e, a[h - e]);
}
if (4 & i) {
if (!a[h - e + 1]) {
const t = new o(new r(n + 1 + 0.5, d - 1 + 0.5), s[h - e + 1], new Map());
(a[h - e + 1] = t), g++;
}
t.neighbors.set(h - e + 1, a[h - e + 1]);
}
if (8 & i) {
if (!a[h + 1]) {
const t = new o(new r(n + 1 + 0.5, d + 0.5), s[h + 1], new Map());
(a[h + 1] = t), g++;
}
t.neighbors.set(h + 1, a[h + 1]);
}
if (16 & i) {
if (!a[h + e + 1]) {
const t = new o(new r(n + 1 + 0.5, d + 1 + 0.5), s[h + e + 1], new Map());
(a[h + e + 1] = t), g++;
}
t.neighbors.set(h + e + 1, a[h + e + 1]);
}
if (32 & i) {
if (!a[h + e]) {
const t = new o(new r(n + 0.5, d + 1 + 0.5), s[h + e], new Map());
(a[h + e] = t), g++;
}
t.neighbors.set(h + e, a[h + e]);
}
if (64 & i) {
if (!a[h + e - 1]) {
const t = new o(new r(n - 1 + 0.5, d + 1 + 0.5), s[h + e - 1], new Map());
(a[h + e - 1] = t), g++;
}
t.neighbors.set(h + e - 1, a[h + e - 1]);
}
if (128 & i) {
if (!a[h - 1]) {
const t = new o(new r(n - 1 + 0.5, d + 0.5), s[h - 1], new Map());
(a[h - 1] = t), g++;
}
t.neighbors.set(h - 1, a[h - 1]);
}
return g;
}),
(d.prototype._recHierarchy = function(t, i, h, e, s) {
const a = h.getCurrentNeighborhood(h.data, i);
if (this._addNeighbors(t, a, i, h.width, e.data, s))
for (let [i, a] of t.getNeighbors()) this._recHierarchy(a, i, h, e, s);
});
var g = d,
w = function(t) {
this.distImg = t;
};
(w.prototype.constructor = w),
(w.prototype.buildHierarchy = function() {
const t = this.distImg.width,
i = this.distImg.height;
for (var h = new Array(t * i), e = 0; e < h.length; ++e) h[e] = !1;
for (
var s = function(i) {
for (
var e = i.position.x,
s = i.position.y,
a = Math.ceil(i.weight),
n = i.position.x - a;
n < i.position.x + a;
n++
)
for (var o = i.position.y - a; o < i.position.y + a; o++) {
if ((n - e) * (n - e) + (o - s) * (o - s) <= a * a) h[o * t + n] = !0;
}
},
a = 0,
n = -1,
d = -1,
g = 0;
g < this.distImg.width;
++g
)
for (var w = 0; w < this.distImg.height; ++w) {
var f = this.distImg.getValue(g, w);
f > a && ((a = f), (n = g), (d = w));
}
var c = new o(new r(n, d), a / this.distImg.getCoeff(), new Map());
s(c);
for (
var u = this,
p = function(i, e) {
for (
var a = 2 * Math.PI * i.weight,
n = Math.round(a),
d = new Array(n),
g = new Array(n),
w = new Array(n),
f = 0;
f < n;
++f
) {
var c = (2 * f * Math.PI) / n,
p = Math.round(i.position.x + Math.cos(c) * (i.weight + 1)),
l = Math.round(i.position.y + Math.sin(c) * (i.weight + 1));
(d[f] = u.distImg.getValue(p, l) / u.distImg.getCoeff()),
(g[f] = p),
(w[f] = l);
}
var y = -1,
I = -1;
for (f = 0; f < d.length; ++f) {
var m = w[f] * t + g[f];
h[m] || (d[f] > y && ((y = d[f]), (I = f)));
}
if (y > 2) {
var b = new o(new r(g[I], w[I]), y, new Map());
return i.getNeighbors().set(g[I] + ";" + w[I], b), s(b), b;
}
return null;
},
l = c;
null !== l;

)
l = p(l);
return c;
}),
(w.prototype.getHierarchyInImageData = function(t) {
var i = this.distImg.getImageData(),
h = [],
e = function(t) {
h.push(t),
t.getNeighbors().forEach(function(t, i, h) {
e(t);
});
};
e(t);
for (var s = 0; s < i.width; ++s)
for (var a = 0; a < i.height; ++a) {
for (var n = 0, o = 0; o < h.length; ++o) {
var r = h[o].position.x + 0.5,
d = h[o].position.y + 0.5;
(s + 0.5 - r) * (s + 0.5 - r) + (a + 0.5 - d) * (a + 0.5 - d) <=
h[o].weight * h[o].weight && n++;
}
var g = 4 * (a * i.width + s);
i.data[g + 1] = (i.data[g] + 255 * n) / (n + 1);
}
for (o = 0; o < h.length; ++o) {
var w = h[o];
g = 4 * (w.position.y * i.width + w.position.x);
(i.data[g] = 255), (i.data[g + 1] = 0), (i.data[g + 2] = 0);
}
return i;
});
var f = w,
c = {};
return (
(c.BinaryImage = i),
(c.IntDistanceImage = e),
(c.SkeletonImage = a),
(c.Skeletonizer = g),
(c.skeletonize = function(t) {
var h = new i(t),
s = new e(3, 4, h, 0),
n = new a(h, 0, 2e3, s);
return {
skeleton: new g(n, s).buildHierarchy(),
binaryImg: h,
distImg: s,
skelImg: n
};
}),
(c.skeletonizeQ = function(t) {
var h = new i(t),
s = new e(3, 4, h, 0),
a = new f(s);
return {
skelImgData: a.getHierarchyInImageData(a.buildHierarchy()),
binaryImg: h,
distImg: s
};
}),
c
);
});
