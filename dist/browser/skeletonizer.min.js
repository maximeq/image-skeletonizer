!(function(t, i) {
"object" == typeof exports && "undefined" != typeof module
? (module.exports = i())
: "function" == typeof define && define.amd
? define(i)
: (t.ImageSkeletonizer = i());
})(this, function() {
"use strict";
var t = function(t, i) {
(this.tolerance = void 0 !== i ? i : 12),
(this.width = t.width),
(this.height = t.height),
(this.data = new Uint8Array(t.width * t.height)),
this._buildBinaryImage(t, this.tolerance);
};
(t.prototype.constructor = t),
(t.prototype.getIndex = function(t, i) {
return i * this.width + t;
}),
(t.prototype.getValue = function(t, i) {
return this.data[this.getIndex(t, i)];
}),
(t.prototype._buildBinaryImage = function(t, i) {
for (var e = this.width * this.height, h = 0; h < e; h++) {
var s = 4 * h;
t.data[s] < 125 && t.data[s + 1] < 125 && t.data[s + 2] < 125
? (this.data[h] = 1)
: (this.data[h] = 0);
}
});
var i = t,
e = function(t, e, h, s) {
if (!(h instanceof i))
throw "IntDistanceImage Error : source must be an instance of BinaryImage";
(this.coeff = t),
(this.width = h.width),
(this.height = h.height),
(this.data = new Array(h.width * h.height)),
this._buildDistanceImage(t, e, h, s);
};
(e.prototype.constructor = e),
(e.prototype.rebuild = function(t, i, e, h) {
(this.coeff = t), this._buildDistanceImage(t, i, e, h, this.data);
}),
(e.prototype.getCoeff = function() {
return this.coeff;
}),
(e.prototype.getIndex = function(t, i) {
return i * this.width + t;
}),
(e.prototype.getValue = function(t, i) {
return this.data[this.getIndex(t, i)];
}),
(e.prototype.getIndexValue = function(t) {
return this.data[t];
}),
(e.prototype.getXFromIndex = function(t) {
return t % this.width;
}),
(e.prototype.getYFromIndex = function(t) {
return Math.round(t / this.width);
}),
(e.prototype._buildDistanceImage = function(t, i, e, h) {
const s = e.width,
a = e.height;
for (let t = 0; t < s; ++t) this.data[t] = 0;
for (let o = 1; o < a - 1; ++o) {
this.data[o * s] = 0;
for (let a = 1; a < s - 1; ++a) {
let s = this.getIndex(a, o);
this.data[s] = 0;
let n = 0;
if (e.data[s] != h) {
let e = this.getIndex(a - 1, o - 1),
h = this.getIndex(a, o - 1),
r = this.getIndex(a - 1, o),
d = this.getIndex(a + 1, o - 1);
(n = Math.min(this.data[e] + i, this.data[h] + t)),
(n = Math.min(n, this.data[r] + t)),
(n = Math.min(n, this.data[d] + i)),
(this.data[s] = n);
}
}
this.data[this.getIndex(s - 1, o)] = 0;
}
for (let t = 0; t < s; ++t) this.data[this.getIndex(t, a - 1)] = 0;
for (let o = a - 2; o > 0; --o)
for (let a = s - 2; a > 0; --a) {
let s = this.getIndex(a, o),
n = this.data[s];
if (e.data[s] != h) {
let e = this.getIndex(a + 1, o + 1),
h = this.getIndex(a, o + 1),
r = this.getIndex(a - 1, o + 1),
d = this.getIndex(a + 1, o);
(n = Math.min(n, this.data[e] + i)),
(n = Math.min(n, this.data[h] + t)),
(n = Math.min(n, this.data[r] + i)),
(this.data[s] = Math.min(n, this.data[d] + t));
}
}
}),
(e.prototype.getImageData = function(t) {
var i = new ImageData(this.width, this.height);
let e = 0;
for (let t = 0; t < this.width * this.height; t++)
e = this.data[t] > e ? this.data[t] : e;
for (let t = 0, h = 0, s = 0; t < this.height; t++)
for (let a = 0; a < this.width; a++) {
let o = t * this.width + a;
this.data[o] > 3
? ((s = (255 * this.data[o]) / e),
  (i.data[h] = s),
  (i.data[h + 1] = s),
  (i.data[h + 2] = s),
  (i.data[h + 3] = 255))
: ((i.data[h] = 255),
  (i.data[h + 1] = 255),
  (i.data[h + 2] = 255),
  (i.data[h + 3] = 255)),
(h += 4);
}
return i;
});
var h = e,
s = function(t, i, e, h) {
(this.width = t.width),
(this.height = t.height),
(this.data = new Array(this.width * this.height));
for (let e = 0; e < this.width * this.height; e++)
t.data[e] != i ? (this.data[e] = 1) : (this.data[e] = 0);
let s = 0;
for (let t = 0; t < h.width * h.height; t++) s = h.data[t] > s ? h.data[t] : s;
this.CleanBorderPixels(),
this.skeletonizeEckhardtMaderlechner93(e, h, 0.8 * s),
this.CleanBorderPixels(),
this.thin();
};
(s.prototype.constructor = s),
(s.prototype.getImageData = function(t, i) {
var e = new ImageData(this.width, this.height),
h = t || [255, 255, 255, 255],
s = i || [255, 0, 0, 255];
let a = 0;
for (let t = 0; t < this.width * this.height; t++)
a = this.data[t] > a ? this.data[t] : a;
for (let t = 0, i = 0; t < this.height; t++)
for (let a = 0; a < this.width; a++) {
let o = t * this.width + a;
1 === this.data[o]
? ((e.data[i] = s[0]),
  (e.data[i + 1] = s[1]),
  (e.data[i + 2] = s[2]),
  (e.data[i + 3] = s[3]))
: ((e.data[i] = h[0]),
  (e.data[i + 1] = h[1]),
  (e.data[i + 2] = h[2]),
  (e.data[i + 3] = h[3])),
(i += 4);
}
return e;
}),
(s.prototype.CleanBorderPixels = function() {
for (let t = 0; t < this.width; t++)
(this.data[t] = 0), (this.data[(this.height - 1) * this.width + t] = 0);
for (let t = 1; t < this.height - 2; t++)
(this.data[t * this.width] = 0),
(this.data[t * this.width + (this.width - 1)] = 0);
}),
(s.prototype.thin = function() {
let t = this.width - 2;
for (let i = 1; i < this.height - 1; i++) {
t += 2;
for (let i = 1; i < this.width - 1; i++) {
if ((t++, 0 == (1 & this.data[t]))) continue;
const i = this.getCurrentNeighborhood(this.data, t);
((0 == (7 & i) && 112 == (112 & i)) ||
(0 == (14 & i) && 160 == (160 & i)) ||
(0 == (28 & i) && 193 == (193 & i)) ||
(0 == (56 & i) && 130 == (130 & i)) ||
(0 == (112 & i) && 7 == (7 & i)) ||
(0 == (224 & i) && 10 == (10 & i)) ||
(0 == (193 & i) && 28 == (28 & i)) ||
(0 == (131 & i) && 40 == (40 & i))) &&
(this.data[t] = 0);
}
}
return this.data;
}),
(s.prototype.skeletonizeEckhardtMaderlechner93 = function(t, i, e) {
const h = this.width * this.height,
s = new Array(this.width * this.height),
a = new Array(this.width * this.height),
o = new Array(this.width * this.height),
n = new Array(this.width * this.height),
r = new Array(this.width * this.height),
d = new Array(this.width * this.height),
g = new Array(this.width * this.height),
f = new Array(this.width * this.height);
let w = !0,
u = 0;
const c = this.width + 1,
l = h - this.width - 1;
for (; w && u < t; ) {
w = !1;
for (let t = c; t < l; t++)
(a[t] = this.getNbStrongNeighbors(this.data, t)),
(o[t] = a[t] + this.getNbNoStrongNeighbors(this.data, t)),
this.data[t]
? 4 == a[t]
  ? ((s[t] = 2), (f[t] = 1))
  : ((s[t] = 1), (f[t] = 2))
: (s[t] = 0);
for (let t = c; t < l; t++)
this.data[t]
? (n[t] =
  1 == s[t] &&
  (2 == s[t + 1] ||
  2 == s[t - 1] ||
  2 == s[t + this.width] ||
  2 == s[t - this.width]))
: (n[t] = !1),
n[t] ? ((n[t] = 1), (f[t] = 3)) : (n[t] = 0);
for (let t = c; t < l; ++t) {
if (this.data[t] && 1 == s[t]) {
let i = 0 != (1 & this.data[t + 1]),
e = 0 != (1 & this.data[t - this.width + 1]),
h = 0 != (1 & this.data[t - this.width]),
a = 0 != (1 & this.data[t - this.width - 1]),
o = 0 != (1 & this.data[t - 1]),
n = 0 != (1 & this.data[t + this.width - 1]),
r = 0 != (1 & this.data[t + this.width]),
g = 0 != (1 & this.data[t + this.width + 1]);
const f =
(1 - i) * e +
(1 - e) * h +
(1 - h) * a +
(1 - a) * o +
(1 - o) * n +
(1 - n) * r +
(1 - r) * g +
(1 - g) * i,
w = i + e + h + a + o + n + r + g,
u = 1 == f || (0 == f && 8 == w);
d[t] = 1 == s[t] && u && (i || h || o || r);
} else d[t] = !1;
d[t] && (f[t] = 4);
}
for (let t = c; t < l; ++t) {
if (this.data[t]) {
const i = 2 == s[t + 1] && !this.data[t - 1],
e = 2 == s[t - 1] && !this.data[t + 1],
h = 2 == s[t + this.width] && !this.data[t - this.width],
a = 2 == s[t - this.width] && !this.data[t + this.width];
r[t] = n[t] && (i || e || h || a);
} else r[t] = !1;
r[t] && (f[t] = 5);
}
for (let t = 0; t < h; ++t)
this.data[t]
? d[t] && r[t]
  ? ((g[t] = 0), (f[t] = 6), (w = !0))
  : 0 == o[t]
  ? (g[t] = 0)
  : i.data[t] < e && 1 == o[t]
  ? ((g[t] = 0), (w = !0))
  : (g[t] = 1)
: ((g[t] = 0), (f[t] = 0));
for (let t = 0; t < g.length; t++) this.data[t] = g[t];
++u;
}
}),
(s.prototype.getCurrentNeighborhood = function(t, i) {
return (
((1 & t[i - 1]) << 7) |
((1 & t[i + 1]) << 3) |
((1 & t[i + this.width]) << 5) |
((1 & t[i - this.width]) << 1) |
(1 & t[i - (this.width + 1)]) |
((1 & t[i - (this.width - 1)]) << 2) |
((1 & t[i + (this.width - 1)]) << 6) |
((1 & t[i + (this.width + 1)]) << 4)
);
}),
(s.prototype.nbNeighbours = function(t) {
return (
(1 & t) +
((t >> 1) & 1) +
((t >> 2) & 1) +
((t >> 3) & 1) +
((t >> 4) & 1) +
((t >> 5) & 1) +
((t >> 6) & 1) +
((t >> 7) & 1)
);
}),
(s.prototype.getNbStrongNeighbors = function(t, i) {
return t[i - 1] + t[i + 1] + t[i - this.width] + t[i + this.width];
}),
(s.prototype.getNbNoStrongNeighbors = function(t, i) {
return (
t[i - 1 - this.width] +
t[i - 1 + this.width] +
t[i + 1 - this.width] +
t[i + 1 + this.width]
);
}),
(s.prototype.isInnerBoundaryPixel = function(t, i) {
return (
(1 == t[i] && 2 == t[i - 1]) ||
2 == t[i + 1] ||
2 == t[i - this.width] ||
2 == t[i + this.width]
);
}),
(s.prototype.isSimpleBoundaryPixel = function(t, i) {
let e = 0 != (1 & t[i + 1]),
h = 0 != (1 & t[i - this.width + 1]),
s = 0 != (1 & t[i - this.width]),
a = 0 != (1 & t[i - this.width - 1]),
o = 0 != (1 & t[i - 1]),
n = 0 != (1 & t[i + this.width - 1]),
r = 0 != (1 & t[i + this.width]),
d = 0 != (1 & t[i + this.width + 1]);
const g =
(1 - e) * h +
(1 - h) * s +
(1 - s) * a +
(1 - a) * o +
(1 - o) * n +
(1 - n) * r +
(1 - r) * d +
(1 - d) * e;
return (
(1 == g || (0 == g && 8 == e + h + s + a + o + n + r + d)) && (e || s || o || r)
);
});
var a = s,
o = function(t, i, e) {
(this.position = t), (this.weight = i), (this.neighbors = e || new Map());
};
(o.prototype.constructor = o),
(o.prototype.getPosition = function() {
return this.position;
}),
(o.prototype.getWeight = function() {
return this.weight;
}),
(o.prototype.getNeighbors = function() {
return this.neighbors;
}),
(o.prototype.setPosition = function(t) {
this.position = t;
}),
(o.prototype.setWeight = function(t) {
this.weight = t;
}),
(o.prototype.setNeighbors = function(t) {
this.neighbors = t;
});
var n = o,
r = function(t, i) {
(this.x = t), (this.y = i);
},
d = function(t, i) {
(this.skelImg = t), (this.distImg = i);
};
(d.prototype.constructor = d),
(d.prototype.buildHierarchy = function() {
const t = this.skelImg.width * this.skelImg.height;
let i = {},
e = [],
h = this._findNextPixelWithNeighbors(this.skelImg, this.distImg, 0);
for (; h < t; ) {
if (void 0 === i[h]) {
const t = h % this.skelImg.width,
s = Math.round(h / this.skelImg.width);
(i[h] = new n(
new r(t + 0.5, s + 0.5),
this.distImg.data[h] / this.distImg.getCoeff()
)),
e.push(i[h]),
this._recHierarchy(i[h], h, this.skelImg, this.distImg, i);
}
h = this._findNextPixelWithNeighbors(this.skelImg, this.distImg, h + 1);
}
return e;
}),
(d.prototype._findNextPixelWithNeighbors = function(t, i, e) {
const h = t.width * t.height;
let s = e;
for (s = e; s < h; s++)
if (1 & t.data[s]) {
if (0 != t.getCurrentNeighborhood(t.data, s)) break;
t.data[s] = 0;
}
return s;
}),
(d.prototype._addNeighbors = function(t, i, e, h, s, a) {
const o = e % h,
d = Math.round(e / h);
let g = 0;
if (1 & i) {
if (void 0 === a[e - h - 1]) {
const t = new n(new r(o - 1 + 0.5, d - 1 + 0.5), s.data[e - h - 1]);
(a[e - h - 1] = t), g++;
}
t.neighbors.set(e - h - 1, a[e - h - 1]);
}
if (2 & i) {
if (void 0 === a[e - h]) {
const t = new n(new r(o + 0.5, d - 1 + 0.5), s.data[e - h]);
(a[e - h] = t), g++;
}
t.neighbors.set(e - h, a[e - h]);
}
if (4 & i) {
if (void 0 === a[e - h + 1]) {
const t = new n(new r(o + 1 + 0.5, d - 1 + 0.5), s.data[e - h + 1]);
(a[e - h + 1] = t), g++;
}
t.neighbors.set(e - h + 1, a[e - h + 1]);
}
if (8 & i) {
if (void 0 === a[e + 1]) {
const t = new n(new r(o + 1 + 0.5, d + 0.5), s.data[e + 1]);
(a[e + 1] = t), g++;
}
t.neighbors.set(e + 1, a[e + 1]);
}
if (16 & i) {
if (void 0 === a[e + h + 1]) {
const t = new n(new r(o + 1 + 0.5, d + 1 + 0.5), s.data[e + h + 1]);
(a[e + h + 1] = t), g++;
}
t.neighbors.set(e + h + 1, a[e + h + 1]);
}
if (32 & i) {
if (void 0 === a[e + h]) {
const t = new n(new r(o + 0.5, d + 1 + 0.5), s.data[e + h]);
(a[e + h] = t), g++;
}
t.neighbors.set(e + h, a[e + h]);
}
if (64 & i) {
if (void 0 === a[e + h - 1]) {
const t = new n(new r(o - 1 + 0.5, d + 1 + 0.5), s.data[e + h - 1]);
(a[e + h - 1] = t), g++;
}
t.neighbors.set(e + h - 1, a[e + h - 1]);
}
if (128 & i) {
if (void 0 === a[e - 1]) {
const t = new n(new r(o - 1 + 0.5, d + 0.5), s.data[e - 1]);
(a[e - 1] = t), g++;
}
t.neighbors.set(e - 1, a[e - 1]);
}
return g;
}),
(d.prototype._recHierarchy = function(t, i, e, h, s) {
const a = e.getCurrentNeighborhood(e.data, i);
if (this._addNeighbors(t, a, i, e.width, h, s))
for (let [i, a] of t.getNeighbors()) this._recHierarchy(a, i, e, h, s);
});
var g = d,
f = function(t) {
this.distImg = t;
};
(f.prototype.constructor = f),
(f.prototype.buildHierarchy = function() {
const t = this.distImg.width,
i = this.distImg.height;
for (var e = {}, h = [], s = new Array(t * i), a = 0; a < s.length; ++a)
s[a] = !1;
for (
var o = this,
d = function(i, e, h) {
if (null === e) {
for (
var a = i.position.x,
n = i.position.y,
r = Math.ceil(i.weight),
d = i.position.x - r;
d < i.position.x + r;
d++
)
for (var g = i.position.y - r; g < i.position.y + r; g++) {
if ((d - a) * (d - a) + (g - n) * (g - n) <= r * r)
(s[(l = g * t + d)] = !0), delete h[l];
}
for (
var f = 2 * Math.PI * (i.weight + 1), w = Math.round(f), u = 0;
u < w;
++u
) {
var c = (2 * u * Math.PI) / w,
l = ((d = Math.round(i.position.x + Math.cos(c) * (i.weight + 1))),
(g = Math.round(i.position.y + Math.sin(c) * (i.weight + 1))) * t + d),
p = o.distImg.getValue(d, g) / o.distImg.getCoeff();
!s[l] && p > 3 && (h[l] = !0);
}
}
},
g = 0,
f = -1,
w = -1,
u = 0;
u < t;
++u
)
for (var c = 0; c < i; ++c) {
var l = this.distImg.getValue(u, c);
l > g && ((g = l), (f = u), (w = c));
}
var p = new n(new r(f, w), g / this.distImg.getCoeff());
(e[this.distImg.getIndex(f, w)] = p), h.push(p);
var y = {};
d(p, null, y);
for (var I = Object.keys(y); 0 !== I.length; ) {
var m = -1,
b = 0;
for (a = 0; a < I.length; ++a) {
var v = parseInt(I[a]);
s[v]
? delete y[I[a]]
: this.distImg.getIndexValue(v) > b &&
  ((b = this.distImg.getIndexValue(v)), (m = v));
}
var x = new n(
new r(this.distImg.getXFromIndex(m), this.distImg.getYFromIndex(m)),
b / this.distImg.getCoeff()
);
(e[m] = x), h.push(x), delete y[m], d(x, null, y), (I = Object.keys(y));
}
return h;
});
var w = f,
u = {};
return (
(u.BinaryImage = i),
(u.IntDistanceImage = h),
(u.SkeletonImage = a),
(u.Skeletonizer = g),
(u.skeletonize = function(t) {
var e = new i(t),
s = new h(3, 4, e, 0),
o = new a(e, 0, 2e3, s);
return {
skeleton: new g(o, s).buildHierarchy(),
binaryImg: e,
distImg: s,
skelImg: o
};
}),
(u.skeletonizeQ = function(t) {
var e = new i(t),
s = new h(3, 4, e, 0);
return {skeleton: new w(s).buildHierarchy(), binaryImg: e, distImg: s};
}),
(u.drawHierarchyInImageData = function(t, i) {
for (
var e = i,
h = {},
s = [],
a = function(t) {
var i = t.position.x + ";" + t.position.y;
void 0 === h[i] &&
((h[i] = t),
s.push(t),
t.getNeighbors().forEach(function(t, i, e) {
a(t);
}));
},
o = 0;
o < t.length;
++o
)
a(t[o]);
for (var n = 0; n < e.width; ++n)
for (var r = 0; r < e.height; ++r) {
var d = 0;
for (o = 0; o < s.length; ++o) {
var g = s[o].position.x + 0.5,
f = s[o].position.y + 0.5;
(n + 0.5 - g) * (n + 0.5 - g) + (r + 0.5 - f) * (r + 0.5 - f) <=
s[o].weight * s[o].weight && d++;
}
var w = 4 * (r * e.width + n);
e.data[w + 1] = (e.data[w] + 255 * d) / (d + 1);
}
for (o = 0; o < s.length; ++o) {
var u = s[o];
w = 4 * (u.position.y * e.width + u.position.x);
(e.data[w] = 255), (e.data[w + 1] = 0), (e.data[w + 2] = 0);
}
return e;
}),
u
);
});
