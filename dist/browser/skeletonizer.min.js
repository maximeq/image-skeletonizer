!(function(t, i) {
"object" == typeof exports && "undefined" != typeof module
? (module.exports = i())
: "function" == typeof define && define.amd
? define(i)
: (t.ImageSkeletonizer = i());
})(this, function() {
"use strict";
var t = function(t, i) {
(this.tolerance = void 0 !== i ? i : 12),
(this.width = t.width),
(this.height = t.height),
(this.data = new Uint8Array(t.width * t.height)),
this._buildBinaryImage(t, this.tolerance);
};
(t.prototype.constructor = t),
(t.prototype.getIndex = function(t, i) {
return i * this.width + t;
}),
(t.prototype.getValue = function(t, i) {
return this.data[this.getIndex(t, i)];
}),
(t.prototype._buildBinaryImage = function(t, i) {
for (var e = this.width * this.height, h = 0; h < e; h++) {
var o = 4 * h;
t.data[o] < 125 && t.data[o + 1] < 125 && t.data[o + 2] < 125
? (this.data[h] = 1)
: (this.data[h] = 0);
}
});
var i = t,
e = function(t, e, h, o) {
if (!(h instanceof i))
throw "IntDistanceImage Error : source must be an instance of BinaryImage";
(this.coeff = t),
(this.width = h.width),
(this.height = h.height),
(this.data = new Array(h.width * h.height)),
this._buildDistanceImage(t, e, h, o);
};
(e.prototype.constructor = e),
(e.prototype.rebuild = function(t, i, e, h) {
(this.coeff = t), this._buildDistanceImage(t, i, e, h, this.data);
}),
(e.prototype.getCoeff = function() {
return this.coeff;
}),
(e.prototype.getIndex = function(t, i) {
return i * this.width + t;
}),
(e.prototype.getValue = function(t, i) {
return this.data[this.getIndex(t, i)];
}),
(e.prototype.getIndexValue = function(t) {
return this.data[t];
}),
(e.prototype.getXFromIndex = function(t) {
return t % this.width;
}),
(e.prototype.getYFromIndex = function(t) {
return Math.round(t / this.width);
}),
(e.prototype._buildDistanceImage = function(t, i, e, h) {
const o = e.width,
n = e.height;
for (let t = 0; t < o; ++t) this.data[t] = 0;
for (let s = 1; s < n - 1; ++s) {
this.data[s * o] = 0;
for (let n = 1; n < o - 1; ++n) {
let o = this.getIndex(n, s);
this.data[o] = 0;
let r = 0;
if (e.data[o] != h) {
let e = this.getIndex(n - 1, s - 1),
h = this.getIndex(n, s - 1),
a = this.getIndex(n - 1, s),
d = this.getIndex(n + 1, s - 1);
(r = Math.min(this.data[e] + i, this.data[h] + t)),
(r = Math.min(r, this.data[a] + t)),
(r = Math.min(r, this.data[d] + i)),
(this.data[o] = r);
}
}
this.data[this.getIndex(o - 1, s)] = 0;
}
for (let t = 0; t < o; ++t) this.data[this.getIndex(t, n - 1)] = 0;
for (let s = n - 2; s > 0; --s)
for (let n = o - 2; n > 0; --n) {
let o = this.getIndex(n, s),
r = this.data[o];
if (e.data[o] != h) {
let e = this.getIndex(n + 1, s + 1),
h = this.getIndex(n, s + 1),
a = this.getIndex(n - 1, s + 1),
d = this.getIndex(n + 1, s);
(r = Math.min(r, this.data[e] + i)),
(r = Math.min(r, this.data[h] + t)),
(r = Math.min(r, this.data[a] + i)),
(this.data[o] = Math.min(r, this.data[d] + t));
}
}
}),
(e.prototype.getImageData = function(t) {
var i = new ImageData(this.width, this.height);
let e = 0;
for (let t = 0; t < this.width * this.height; t++)
e = this.data[t] > e ? this.data[t] : e;
for (let t = 0, h = 0, o = 0; t < this.height; t++)
for (let n = 0; n < this.width; n++) {
let s = t * this.width + n;
this.data[s] > 3
? ((o = (255 * this.data[s]) / e),
  (i.data[h] = o),
  (i.data[h + 1] = o),
  (i.data[h + 2] = o),
  (i.data[h + 3] = 255))
: ((i.data[h] = 255),
  (i.data[h + 1] = 255),
  (i.data[h + 2] = 255),
  (i.data[h + 3] = 255)),
(h += 4);
}
return i;
});
var h = e,
o = function(t, i, e, h) {
(this.width = t.width),
(this.height = t.height),
(this.data = new Array(this.width * this.height));
for (let e = 0; e < this.width * this.height; e++)
t.data[e] != i ? (this.data[e] = 1) : (this.data[e] = 0);
let o = 0;
for (let t = 0; t < h.width * h.height; t++) o = h.data[t] > o ? h.data[t] : o;
this.CleanBorderPixels(),
this.skeletonizeEckhardtMaderlechner93(e, h, 0.8 * o),
this.CleanBorderPixels(),
this.thin();
};
(o.prototype.constructor = o),
(o.prototype.getIndex = function(t, i) {
return i * this.width + t;
}),
(o.prototype.getImageData = function(t, i) {
var e = new ImageData(this.width, this.height),
h = t || [255, 255, 255, 255],
o = i || [255, 0, 0, 255];
let n = 0;
for (let t = 0; t < this.width * this.height; t++)
n = this.data[t] > n ? this.data[t] : n;
for (let t = 0, i = 0; t < this.height; t++)
for (let n = 0; n < this.width; n++) {
let s = t * this.width + n;
1 === this.data[s]
? ((e.data[i] = o[0]),
  (e.data[i + 1] = o[1]),
  (e.data[i + 2] = o[2]),
  (e.data[i + 3] = o[3]))
: ((e.data[i] = h[0]),
  (e.data[i + 1] = h[1]),
  (e.data[i + 2] = h[2]),
  (e.data[i + 3] = h[3])),
(i += 4);
}
return e;
}),
(o.prototype.CleanBorderPixels = function() {
for (let t = 0; t < this.width; t++)
(this.data[t] = 0), (this.data[(this.height - 1) * this.width + t] = 0);
for (let t = 1; t < this.height - 2; t++)
(this.data[t * this.width] = 0),
(this.data[t * this.width + (this.width - 1)] = 0);
}),
(o.prototype.thin = function() {
let t = this.width - 2;
for (let i = 1; i < this.height - 1; i++) {
t += 2;
for (let i = 1; i < this.width - 1; i++) {
if ((t++, 0 == (1 & this.data[t]))) continue;
const i = this.getCurrentNeighborhood(t);
((0 == (7 & i) && 112 == (112 & i)) ||
(0 == (14 & i) && 160 == (160 & i)) ||
(0 == (28 & i) && 193 == (193 & i)) ||
(0 == (56 & i) && 130 == (130 & i)) ||
(0 == (112 & i) && 7 == (7 & i)) ||
(0 == (224 & i) && 10 == (10 & i)) ||
(0 == (193 & i) && 28 == (28 & i)) ||
(0 == (131 & i) && 40 == (40 & i))) &&
(this.data[t] = 0);
}
}
return this.data;
}),
(o.prototype.skeletonizeEckhardtMaderlechner93 = function(t, i, e) {
const h = this.width * this.height,
o = new Array(this.width * this.height),
n = new Array(this.width * this.height),
s = new Array(this.width * this.height),
r = new Array(this.width * this.height),
a = new Array(this.width * this.height),
d = new Array(this.width * this.height),
g = new Array(this.width * this.height),
f = new Array(this.width * this.height);
let u = !0,
c = 0;
const y = this.width + 1,
p = h - this.width - 1;
for (; u && c < t; ) {
u = !1;
for (let t = y; t < p; t++)
(n[t] = this.getNbStrongNeighbors(this.data, t)),
(s[t] = n[t] + this.getNbNoStrongNeighbors(this.data, t)),
this.data[t]
? 4 == n[t]
  ? ((o[t] = 2), (f[t] = 1))
  : ((o[t] = 1), (f[t] = 2))
: (o[t] = 0);
for (let t = y; t < p; t++)
this.data[t]
? (r[t] =
  1 == o[t] &&
  (2 == o[t + 1] ||
  2 == o[t - 1] ||
  2 == o[t + this.width] ||
  2 == o[t - this.width]))
: (r[t] = !1),
r[t] ? ((r[t] = 1), (f[t] = 3)) : (r[t] = 0);
for (let t = y; t < p; ++t) {
if (this.data[t] && 1 == o[t]) {
let i = 0 != (1 & this.data[t + 1]),
e = 0 != (1 & this.data[t - this.width + 1]),
h = 0 != (1 & this.data[t - this.width]),
n = 0 != (1 & this.data[t - this.width - 1]),
s = 0 != (1 & this.data[t - 1]),
r = 0 != (1 & this.data[t + this.width - 1]),
a = 0 != (1 & this.data[t + this.width]),
g = 0 != (1 & this.data[t + this.width + 1]);
const f =
(1 - i) * e +
(1 - e) * h +
(1 - h) * n +
(1 - n) * s +
(1 - s) * r +
(1 - r) * a +
(1 - a) * g +
(1 - g) * i,
u = i + e + h + n + s + r + a + g,
c = 1 == f || (0 == f && 8 == u);
d[t] = 1 == o[t] && c && (i || h || s || a);
} else d[t] = !1;
d[t] && (f[t] = 4);
}
for (let t = y; t < p; ++t) {
if (this.data[t]) {
const i = 2 == o[t + 1] && !this.data[t - 1],
e = 2 == o[t - 1] && !this.data[t + 1],
h = 2 == o[t + this.width] && !this.data[t - this.width],
n = 2 == o[t - this.width] && !this.data[t + this.width];
a[t] = r[t] && (i || e || h || n);
} else a[t] = !1;
a[t] && (f[t] = 5);
}
for (let t = 0; t < h; ++t)
this.data[t]
? d[t] && a[t]
  ? ((g[t] = 0), (f[t] = 6), (u = !0))
  : 0 == s[t]
  ? (g[t] = 0)
  : i.data[t] < e && 1 == s[t]
  ? ((g[t] = 0), (u = !0))
  : (g[t] = 1)
: ((g[t] = 0), (f[t] = 0));
for (let t = 0; t < g.length; t++) this.data[t] = g[t];
++c;
}
}),
(o.prototype.getCurrentNeighborhood = function(t) {
var i = this.data;
return (
((1 & i[t - 1]) << 7) |
((1 & i[t + 1]) << 3) |
((1 & i[t + this.width]) << 5) |
((1 & i[t - this.width]) << 1) |
(1 & i[t - (this.width + 1)]) |
((1 & i[t - (this.width - 1)]) << 2) |
((1 & i[t + (this.width - 1)]) << 6) |
((1 & i[t + (this.width + 1)]) << 4)
);
}),
(o.prototype.nbNeighbours = function(t) {
return (
(1 & t) +
((t >> 1) & 1) +
((t >> 2) & 1) +
((t >> 3) & 1) +
((t >> 4) & 1) +
((t >> 5) & 1) +
((t >> 6) & 1) +
((t >> 7) & 1)
);
}),
(o.prototype.getNbStrongNeighbors = function(t, i) {
return t[i - 1] + t[i + 1] + t[i - this.width] + t[i + this.width];
}),
(o.prototype.getNbNoStrongNeighbors = function(t, i) {
return (
t[i - 1 - this.width] +
t[i - 1 + this.width] +
t[i + 1 - this.width] +
t[i + 1 + this.width]
);
}),
(o.prototype.isInnerBoundaryPixel = function(t, i) {
return (
(1 == t[i] && 2 == t[i - 1]) ||
2 == t[i + 1] ||
2 == t[i - this.width] ||
2 == t[i + this.width]
);
}),
(o.prototype.isSimpleBoundaryPixel = function(t, i) {
let e = 0 != (1 & t[i + 1]),
h = 0 != (1 & t[i - this.width + 1]),
o = 0 != (1 & t[i - this.width]),
n = 0 != (1 & t[i - this.width - 1]),
s = 0 != (1 & t[i - 1]),
r = 0 != (1 & t[i + this.width - 1]),
a = 0 != (1 & t[i + this.width]),
d = 0 != (1 & t[i + this.width + 1]);
const g =
(1 - e) * h +
(1 - h) * o +
(1 - o) * n +
(1 - n) * s +
(1 - s) * r +
(1 - r) * a +
(1 - a) * d +
(1 - d) * e;
return (
(1 == g || (0 == g && 8 == e + h + o + n + s + r + a + d)) && (e || o || s || a)
);
});
var n = o,
s = function(t, i) {
(this.position = t), (this.weight = i), (this.neighbors = new Map());
};
(s.computeKey = function(t, i) {
return Math.floor(t) + ";" + Math.floor(i);
}),
(s.getXYFromKey = function(t) {
var i = t.split(";");
return (i[0] = parseInt(i[0])), (i[1] = parseInt(i[1])), i;
}),
(s.prototype.constructor = s),
(s.prototype.getKey = function() {
return this.computeKey(this.position.x, this.position.y);
}),
(s.prototype.getPosition = function() {
return this.position;
}),
(s.prototype.getWeight = function() {
return this.weight;
}),
(s.prototype.getNeighbors = function() {
return this.neighbors;
}),
(s.prototype.setPosition = function(t) {
this.position = t;
}),
(s.prototype.setWeight = function(t) {
this.weight = t;
}),
(s.prototype.setNeighbors = function(t) {
this.neighbors = t;
});
var r = s,
a = function(t, i) {
(this.x = t), (this.y = i);
};
(a.prototype.distanceToOrigin = function(t) {
var i = this.x,
e = this.y;
return Math.sqrt(i * i + e * e);
}),
(a.prototype.distanceTo = function(t) {
var i = this.x - t.x,
e = this.y - t.y;
return Math.sqrt(i * i + e * e);
}),
(a.prototype.barycenter = function(t, i, e, h) {
var o = h / (e + h);
return (
(this.x = (1 - o) * t.x + o * i.x), (this.y = (1 - o) * t.y + o * i.y), this
);
});
var d = a,
g = function(t, i) {
(this.x = t || 0), (this.y = i || 0);
};
(g.prototype.length = function(t) {
var i = this.x,
e = this.y;
return Math.sqrt(i * i + e * e);
}),
(g.prototype.subPoints = function(t, i) {
t.x, i.x, t.yp2.y;
return this;
});
var f = g,
u = function(t, i) {
(this.skelImg = t), (this.distImg = i);
};
(u.prototype.constructor = u),
(u.prototype.buildHierarchy = function() {
const t = this.skelImg.width * this.skelImg.height;
let i = {},
e = [],
h = this._findNextPixelWithNeighbors(this.skelImg, this.distImg, 0);
for (; h < t; ) {
if (void 0 === i[h]) {
const t = h % this.skelImg.width,
o = Math.round(h / this.skelImg.width);
(i[h] = new r(
new d(t + 0.5, o + 0.5),
this.distImg.data[h] / this.distImg.getCoeff()
)),
e.push(i[h]),
this._recHierarchy(i[h], h, i);
}
h = this._findNextPixelWithNeighbors(h + 1);
}
return e;
}),
(u.prototype._simplifyHierarchy = function(t, i, e) {
var h = t.position();
if (1 === t.getNeighbors().size()) {
var o = t
.getNeighbors()
.keys()
.next()
.value.position();
new f().subPoints(o, h);
}
}),
(u.prototype._findNextPixelWithNeighbors = function(t) {
const i = this.skelImg.width * this.skelImg.height;
let e = t;
for (e = t; e < i; e++)
if (1 & this.skelImg.data[e]) {
if (0 != this.skelImg.getCurrentNeighborhood(e)) break;
this.skelImg.data[e] = 0;
}
return e;
}),
(u.prototype._checkAndCreate = function(t, i, e, h) {
var o = r.computeKey(t, i);
void 0 === h[o] &&
((h[o] = new r(new d(t + 0.5, i + 0.5), this.distImg.getValue(t, i))),
newElement++),
e.neighbors.set(o, h[o]);
}),
(u.prototype._addNeighbors = function(t, i, e) {
this.skelImg.width;
const h = Math.floor(t.position.x),
o = Math.floor(t.position.y);
if ((1 & i && this._checkAndCreate(h - 1, o - 1, t, e), 2 & i)) {
r.computeKey(h, o - 1);
this._checkAndCreate(h, o - 1, t, e);
}
return (
4 & i && this._checkAndCreate(h + 1, o - 1, t, e),
8 & i && this._checkAndCreate(h + 1, o, t, e),
16 & i && this._checkAndCreate(h + 1, o + 1, t, e),
32 & i && this._checkAndCreate(h, o + 1, t, e),
64 & i && this._checkAndCreate(h - 1, o + 1, t, e),
128 & i && this._checkAndCreate(h - 1, o, t, e),
0
);
}),
(u.prototype._addNeighborsOLD = function(t, i, e, h) {
const o = this.skelImg.width,
n = e % o,
s = Math.round(e / o);
let a = 0;
if (1 & i) {
if (void 0 === h[e - o - 1]) {
const t = new r(
new d(n - 1 + 0.5, s - 1 + 0.5),
this.distImg.getIndexValue(e - o - 1)
);
(h[e - o - 1] = t), a++;
}
t.neighbors.set(e - o - 1, h[e - o - 1]);
}
if (2 & i) {
if (void 0 === h[e - o]) {
const t = new r(new d(n + 0.5, s - 1 + 0.5), this.distImg.getIndexValue(e - o));
(h[e - o] = t), a++;
}
t.neighbors.set(e - o, h[e - o]);
}
if (4 & i) {
if (void 0 === h[e - o + 1]) {
const t = new r(
new d(n + 1 + 0.5, s - 1 + 0.5),
this.distImg.getIndexValue(e - o + 1)
);
(h[e - o + 1] = t), a++;
}
t.neighbors.set(e - o + 1, h[e - o + 1]);
}
if (8 & i) {
if (void 0 === h[e + 1]) {
const t = new r(new d(n + 1 + 0.5, s + 0.5), this.distImg.getIndexValue(e + 1));
(h[e + 1] = t), a++;
}
t.neighbors.set(e + 1, h[e + 1]);
}
if (16 & i) {
if (void 0 === h[e + o + 1]) {
const t = new r(
new d(n + 1 + 0.5, s + 1 + 0.5),
this.distImg.getIndexValue(e + o + 1)
);
(h[e + o + 1] = t), a++;
}
t.neighbors.set(e + o + 1, h[e + o + 1]);
}
if (32 & i) {
if (void 0 === h[e + o]) {
const t = new r(new d(n + 0.5, s + 1 + 0.5), this.distImg.getIndexValue(e + o));
(h[e + o] = t), a++;
}
t.neighbors.set(e + o, h[e + o]);
}
if (64 & i) {
if (void 0 === h[e + o - 1]) {
const t = new r(
new d(n - 1 + 0.5, s + 1 + 0.5),
this.distImg.getIndexValue(e + o - 1)
);
(h[e + o - 1] = t), a++;
}
t.neighbors.set(e + o - 1, h[e + o - 1]);
}
if (128 & i) {
if (void 0 === h[e - 1]) {
const t = new r(new d(n - 1 + 0.5, s + 0.5), this.distImg.getIndexValue(e - 1));
(h[e - 1] = t), a++;
}
t.neighbors.set(e - 1, h[e - 1]);
}
return a;
}),
(u.prototype._recHierarchy = function(t, i) {
const e = this.skelImg.getCurrentNeighborhood(
this.skelImg.getIndex(Math.floor(t.position.x), Math.floor(t.position.y))
);
if (this._addNeighbors(t, e, i))
for (let [e, h] of t.getNeighbors()) this._recHierarchy(h, i);
});
var c = u,
y = function(t, i, e, h, o) {
var n = new d(i.x - t.x, i.y - t.y),
s = n.distanceToOrigin();
(n.x = n.x / s), (n.y = n.y / s);
var r = new d(o.x - t.x, o.y - t.y),
a = r.distanceToOrigin(),
g = a * a,
f = r.x * n.x + r.y * n.y,
u = (f + (-Math.sqrt(Math.max(0, g - f * f)) / s) * (e - h)) / s;
u > 1 && (u = 1), u < 0 && (u = 0);
var c = new d(t.x, t.y);
return (
(c.x += (i.x - c.x) * u),
(c.y += (i.y - c.y) * u),
(c.z += (i.z - c.z) * u),
(r.x = o.x - c.x),
(r.y = o.y - c.y),
r.distanceToOrigin() - (u * h + (1 - u) * e)
);
},
p = function(t) {
this.distImg = t;
};
(p.prototype.constructor = p),
(p.prototype.buildHierarchy = function() {
var t = this;
const i = this.distImg.width,
e = this.distImg.height;
for (var h = {}, o = {}, n = [], s = new Array(i * e), a = 0; a < s.length; ++a)
s[a] = !1;
for (
var g = function(e, h, o) {
for (
var n = e.position.x,
r = e.position.y,
a = e.getPosition(),
g = Math.ceil(e.weight),
f = h ? Math.ceil(h.getWeight()) : 0,
u = h ? h.getPosition() : null,
c = new d(0, 0),
p = {
min: {
x: h ? Math.min(a.x - g, u.x - f) : a.x - g,
y: h ? Math.min(a.y - g, u.y - f) : a.y - g
},
max: {
x: h ? Math.max(a.x + g, u.x + f) : a.x + g,
y: h ? Math.max(a.y + g, u.y + f) : a.y + g
}
},
w = p.min.x;
w < p.max.x;
w++
)
for (var l = p.min.y; l < p.max.y; l++) {
(c.x = w), (c.y = l);
var x = h
? y(e.getPosition(), h.getPosition(), g, Math.ceil(h.weight), c)
: (w - n) * (w - n) + (l - r) * (l - r);
if (h ? x <= 0 : x <= g * g) (s[(M = l * i + w)] = !0), delete o[M];
}
for (
var I = 2 * Math.PI * (e.weight + 1), m = Math.round(I), v = 0;
v < m;
++v
) {
var b = (2 * v * Math.PI) / m,
M = ((w = Math.round(e.position.x + Math.cos(b) * (e.weight + 1))),
(l = Math.round(e.position.y + Math.sin(b) * (e.weight + 1))) * i + w),
k = t.distImg.getValue(w, l) / t.distImg.getCoeff();
!s[M] && k > 3 && (o[M] = e);
}
},
f = 0,
u = -1,
c = -1,
p = 0;
p < i;
++p
)
for (var w = 0; w < e; ++w) {
var l = this.distImg.getValue(p, w);
l > f && ((f = l), (u = p), (c = w));
}
var x = new r(new d(u, c), f / this.distImg.getCoeff());
(o[this.distImg.getIndex(u, c)] = x), n.push(x), g(x, null, h);
for (var I = 0, m = Object.keys(h); 0 !== m.length && I < 1e4; ) {
var v = -1,
b = 0;
for (a = 0; a < m.length; ++a) {
var M = parseInt(m[a]);
s[M]
? delete h[m[a]]
: this.distImg.getIndexValue(M) > b &&
  ((b = this.distImg.getIndexValue(M)), (v = M));
}
b /= this.distImg.getCoeff();
var k = new d(this.distImg.getXFromIndex(v), this.distImg.getYFromIndex(v)),
N = h[v],
C = {v: b, p: new d(k.x, k.y), idx: v};
(function() {
var i = N.getPosition().distanceTo(k),
e = new d(0, 0);
e.barycenter(k, N.getPosition(), 0.5, 0.5),
(e.x = Math.round(e.x)),
(e.y = Math.round(e.y));
var h = t.distImg.getValue(e.x, e.y) / t.distImg.getCoeff(),
o = new d(0, 0),
n = new d(k.x - N.getPosition().x, k.y - N.getPosition().y);
(n.x /= i), (n.y /= i);
for (
var s = new d(-n.y, n.x),
r = {v: h, p: new d(e.x, e.y), idx: v},
a = Math.max(N.getWeight() / 2, 3),
g = -a;
g <= a;
g++
) {
(o.x = Math.round(e.x + g * s.x)), (o.y = Math.round(e.y + g * s.y));
var f = t.distImg.getValue(o.x, o.y) / t.distImg.getCoeff();
f > r.v && f > h + 1.5 && ((r.v = f), (r.p.x = o.x), (r.p.y = o.y));
}
return (
(r.p.x !== e.x || r.p.y !== e.y) &&
((C.v = r.v),
(C.p.x = r.p.x),
(C.p.y = r.p.y),
(C.idx = t.distImg.getIndex(r.p.x, r.p.y)),
!0)
);
})() ||
(function() {
for (
var i = N.getPosition().distanceTo(k), e = new d(0, 0), h = 1;
h < i;
h += 1
) {
var o = h / i;
e.barycenter(k, N.getPosition(), 1 - o, o),
(e.x = Math.round(e.x)),
(e.y = Math.round(e.y));
var n = t.distImg.getValue(e.x, e.y) / t.distImg.getCoeff(),
s = h + b - n,
r = (1 - o) * b + o * N.weight;
s < 1 &&
n > r &&
((C.v = n),
(C.p.x = e.x),
(C.p.y = e.y),
(C.idx = t.distImg.getIndex(e.x, e.y)));
}
})();
var P = new r(C.p, C.v);
P.neighbors.set(this.distImg.getIndex(N.position.x, N.position.y), N),
N.neighbors.set(this.distImg.getIndex(P.position.x, P.position.y), P),
(o[C.idx] = P),
n.push(P),
delete h[v],
delete h[C.idx],
g(P, N, h),
(m = Object.keys(h)),
I++;
}
return {hierarchy: n, covered: s};
});
var w = p,
l = {};
return (
(l.BinaryImage = i),
(l.IntDistanceImage = h),
(l.SkeletonImage = n),
(l.Skeletonizer = c),
(l.skeletonize = function(t) {
var e = new i(t),
o = new h(3, 4, e, 0),
s = new n(e, 0, 2e3, o);
return {
skeleton: new c(s, o).buildHierarchy(),
binaryImg: e,
distImg: o,
skelImg: s
};
}),
(l.skeletonizeQ = function(t) {
var e = new i(t),
o = new h(3, 4, e, 0),
n = new w(o).buildHierarchy();
return {skeleton: n.hierarchy, binaryImg: e, distImg: o, covered: n.covered};
}),
(l.drawHierarchyInImageData = function(t, i) {
for (
var e = i,
h = {},
o = [],
n = function(t) {
var i = t.position.x + ";" + t.position.y;
void 0 === h[i] &&
((h[i] = t),
o.push(t),
t.getNeighbors().forEach(function(t, i, e) {
n(t);
}));
},
s = 0;
s < t.length;
++s
)
n(t[s]);
for (var r = 0; r < e.width; ++r)
for (var a = 0; a < e.height; ++a) {
var d = 0;
for (s = 0; s < o.length; ++s) {
var g = o[s].position.x + 0.5,
f = o[s].position.y + 0.5;
(r + 0.5 - g) * (r + 0.5 - g) + (a + 0.5 - f) * (a + 0.5 - f) <=
o[s].weight * o[s].weight && d++;
}
var u = 4 * (a * e.width + r);
e.data[u + 1] = (e.data[u + 1] + 255 * d) / (d + 1);
}
for (s = 0; s < o.length; ++s) {
var c = o[s];
u = 4 * (c.position.y * e.width + c.position.x);
(e.data[u] = 255), (e.data[u + 1] = 0), (e.data[u + 2] = 0);
}
return e;
}),
(l.drawCoverInImageData = function(t, i) {
for (var e = i, h = 0; h < e.width; ++h)
for (var o = 0; o < e.height; ++o) {
var n = o * e.width + h;
t[n] && ((n *= 4), (e.data[n + 1] = (e.data[n + 1] + 255) / 2));
}
return e;
}),
(l.drawHierarchyInCanvas = function(t, i) {
for (
var e = i.getContext("2d"),
h = {},
o = [],
n = function(t) {
var i = t.position.x + ";" + t.position.y;
void 0 === h[i] &&
((h[i] = t),
o.push(t),
t.getNeighbors().forEach(function(t, i, e) {
n(t);
}));
},
s = 0;
s < t.length;
++s
)
n(t[s]);
for (s = 0; s < o.length; ++s) {
var r = o[s];
r.getNeighbors().forEach(function(t, i, h) {
(e.lineWidth = 1),
(e.strokeStyle = "#ff0000"),
e.beginPath(),
e.moveTo(r.position.x, r.position.y),
e.lineTo(t.position.x, t.position.y),
e.stroke(),
(e.fillStyle = "#0000ff"),
e.fillRect(r.position.x, r.position.y, 1, 1),
e.fillRect(t.position.x, t.position.y, 1, 1);
});
}
}),
l
);
});
