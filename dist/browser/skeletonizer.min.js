!(function(t, i) {
"object" == typeof exports && "undefined" != typeof module
? (module.exports = i())
: "function" == typeof define && define.amd
? define(i)
: (t.ImageSkeletonizer = i());
})(this, function() {
"use strict";
var t = function(t, i) {
(this.tolerance = void 0 !== i ? i : 12),
(this.width = t.width),
(this.height = t.height),
(this.data = new Uint8Array(t.width * t.height)),
this._buildBinaryImage(t, this.tolerance);
};
(t.prototype.constructor = t),
(t.prototype.getIndex = function(t, i) {
return i * this.width + t;
}),
(t.prototype.getValue = function(t, i) {
return this.data[this.getIndex(t, i)];
}),
(t.prototype._buildBinaryImage = function(t, i) {
for (var e = this.width * this.height, h = 0; h < e; h++) {
var o = 4 * h;
t.data[o] < 125 && t.data[o + 1] < 125 && t.data[o + 2] < 125
? (this.data[h] = 1)
: (this.data[h] = 0);
}
});
var i = t,
e = function(t, e, h, o) {
if (!(h instanceof i))
throw "IntDistanceImage Error : source must be an instance of BinaryImage";
(this.coeff = t),
(this.width = h.width),
(this.height = h.height),
(this.data = new Array(h.width * h.height)),
this._buildDistanceImage(t, e, h, o);
};
(e.prototype.constructor = e),
(e.prototype.rebuild = function(t, i, e, h) {
(this.coeff = t), this._buildDistanceImage(t, i, e, h, this.data);
}),
(e.prototype.getCoeff = function() {
return this.coeff;
}),
(e.prototype.getIndex = function(t, i) {
return i * this.width + t;
}),
(e.prototype.getValue = function(t, i) {
return this.data[this.getIndex(t, i)];
}),
(e.prototype.getIndexValue = function(t) {
return this.data[t];
}),
(e.prototype.getXFromIndex = function(t) {
return t % this.width;
}),
(e.prototype.getYFromIndex = function(t) {
return Math.round(t / this.width);
}),
(e.prototype._buildDistanceImage = function(t, i, e, h) {
const o = e.width,
n = e.height;
for (let t = 0; t < o; ++t) this.data[t] = 0;
for (let s = 1; s < n - 1; ++s) {
this.data[s * o] = 0;
for (let n = 1; n < o - 1; ++n) {
let o = this.getIndex(n, s);
this.data[o] = 0;
let a = 0;
if (e.data[o] != h) {
let e = this.getIndex(n - 1, s - 1),
h = this.getIndex(n, s - 1),
r = this.getIndex(n - 1, s),
d = this.getIndex(n + 1, s - 1);
(a = Math.min(this.data[e] + i, this.data[h] + t)),
(a = Math.min(a, this.data[r] + t)),
(a = Math.min(a, this.data[d] + i)),
(this.data[o] = a);
}
}
this.data[this.getIndex(o - 1, s)] = 0;
}
for (let t = 0; t < o; ++t) this.data[this.getIndex(t, n - 1)] = 0;
for (let s = n - 2; s > 0; --s)
for (let n = o - 2; n > 0; --n) {
let o = this.getIndex(n, s),
a = this.data[o];
if (e.data[o] != h) {
let e = this.getIndex(n + 1, s + 1),
h = this.getIndex(n, s + 1),
r = this.getIndex(n - 1, s + 1),
d = this.getIndex(n + 1, s);
(a = Math.min(a, this.data[e] + i)),
(a = Math.min(a, this.data[h] + t)),
(a = Math.min(a, this.data[r] + i)),
(this.data[o] = Math.min(a, this.data[d] + t));
}
}
}),
(e.prototype.getImageData = function(t) {
var i = new ImageData(this.width, this.height);
let e = 0;
for (let t = 0; t < this.width * this.height; t++)
e = this.data[t] > e ? this.data[t] : e;
for (let t = 0, h = 0, o = 0; t < this.height; t++)
for (let n = 0; n < this.width; n++) {
let s = t * this.width + n;
this.data[s] > 3
? ((o = (255 * this.data[s]) / e),
  (i.data[h] = o),
  (i.data[h + 1] = o),
  (i.data[h + 2] = o),
  (i.data[h + 3] = 255))
: ((i.data[h] = 255),
  (i.data[h + 1] = 255),
  (i.data[h + 2] = 255),
  (i.data[h + 3] = 255)),
(h += 4);
}
return i;
});
var h = e,
o = function(t, i, e, h) {
(this.width = t.width),
(this.height = t.height),
(this.data = new Array(this.width * this.height));
for (let e = 0; e < this.width * this.height; e++)
t.data[e] != i ? (this.data[e] = 1) : (this.data[e] = 0);
let o = 0;
for (let t = 0; t < h.width * h.height; t++) o = h.data[t] > o ? h.data[t] : o;
this.CleanBorderPixels(),
this.skeletonizeEckhardtMaderlechner93(e, h, 0.8 * o),
this.CleanBorderPixels(),
this.thin();
};
(o.prototype.constructor = o),
(o.prototype.getImageData = function(t, i) {
var e = new ImageData(this.width, this.height),
h = t || [255, 255, 255, 255],
o = i || [255, 0, 0, 255];
let n = 0;
for (let t = 0; t < this.width * this.height; t++)
n = this.data[t] > n ? this.data[t] : n;
for (let t = 0, i = 0; t < this.height; t++)
for (let n = 0; n < this.width; n++) {
let s = t * this.width + n;
1 === this.data[s]
? ((e.data[i] = o[0]),
  (e.data[i + 1] = o[1]),
  (e.data[i + 2] = o[2]),
  (e.data[i + 3] = o[3]))
: ((e.data[i] = h[0]),
  (e.data[i + 1] = h[1]),
  (e.data[i + 2] = h[2]),
  (e.data[i + 3] = h[3])),
(i += 4);
}
return e;
}),
(o.prototype.CleanBorderPixels = function() {
for (let t = 0; t < this.width; t++)
(this.data[t] = 0), (this.data[(this.height - 1) * this.width + t] = 0);
for (let t = 1; t < this.height - 2; t++)
(this.data[t * this.width] = 0),
(this.data[t * this.width + (this.width - 1)] = 0);
}),
(o.prototype.thin = function() {
let t = this.width - 2;
for (let i = 1; i < this.height - 1; i++) {
t += 2;
for (let i = 1; i < this.width - 1; i++) {
if ((t++, 0 == (1 & this.data[t]))) continue;
const i = this.getCurrentNeighborhood(this.data, t);
((0 == (7 & i) && 112 == (112 & i)) ||
(0 == (14 & i) && 160 == (160 & i)) ||
(0 == (28 & i) && 193 == (193 & i)) ||
(0 == (56 & i) && 130 == (130 & i)) ||
(0 == (112 & i) && 7 == (7 & i)) ||
(0 == (224 & i) && 10 == (10 & i)) ||
(0 == (193 & i) && 28 == (28 & i)) ||
(0 == (131 & i) && 40 == (40 & i))) &&
(this.data[t] = 0);
}
}
return this.data;
}),
(o.prototype.skeletonizeEckhardtMaderlechner93 = function(t, i, e) {
const h = this.width * this.height,
o = new Array(this.width * this.height),
n = new Array(this.width * this.height),
s = new Array(this.width * this.height),
a = new Array(this.width * this.height),
r = new Array(this.width * this.height),
d = new Array(this.width * this.height),
g = new Array(this.width * this.height),
f = new Array(this.width * this.height);
let w = !0,
u = 0;
const y = this.width + 1,
c = h - this.width - 1;
for (; w && u < t; ) {
w = !1;
for (let t = y; t < c; t++)
(n[t] = this.getNbStrongNeighbors(this.data, t)),
(s[t] = n[t] + this.getNbNoStrongNeighbors(this.data, t)),
this.data[t]
? 4 == n[t]
  ? ((o[t] = 2), (f[t] = 1))
  : ((o[t] = 1), (f[t] = 2))
: (o[t] = 0);
for (let t = y; t < c; t++)
this.data[t]
? (a[t] =
  1 == o[t] &&
  (2 == o[t + 1] ||
  2 == o[t - 1] ||
  2 == o[t + this.width] ||
  2 == o[t - this.width]))
: (a[t] = !1),
a[t] ? ((a[t] = 1), (f[t] = 3)) : (a[t] = 0);
for (let t = y; t < c; ++t) {
if (this.data[t] && 1 == o[t]) {
let i = 0 != (1 & this.data[t + 1]),
e = 0 != (1 & this.data[t - this.width + 1]),
h = 0 != (1 & this.data[t - this.width]),
n = 0 != (1 & this.data[t - this.width - 1]),
s = 0 != (1 & this.data[t - 1]),
a = 0 != (1 & this.data[t + this.width - 1]),
r = 0 != (1 & this.data[t + this.width]),
g = 0 != (1 & this.data[t + this.width + 1]);
const f =
(1 - i) * e +
(1 - e) * h +
(1 - h) * n +
(1 - n) * s +
(1 - s) * a +
(1 - a) * r +
(1 - r) * g +
(1 - g) * i,
w = i + e + h + n + s + a + r + g,
u = 1 == f || (0 == f && 8 == w);
d[t] = 1 == o[t] && u && (i || h || s || r);
} else d[t] = !1;
d[t] && (f[t] = 4);
}
for (let t = y; t < c; ++t) {
if (this.data[t]) {
const i = 2 == o[t + 1] && !this.data[t - 1],
e = 2 == o[t - 1] && !this.data[t + 1],
h = 2 == o[t + this.width] && !this.data[t - this.width],
n = 2 == o[t - this.width] && !this.data[t + this.width];
r[t] = a[t] && (i || e || h || n);
} else r[t] = !1;
r[t] && (f[t] = 5);
}
for (let t = 0; t < h; ++t)
this.data[t]
? d[t] && r[t]
  ? ((g[t] = 0), (f[t] = 6), (w = !0))
  : 0 == s[t]
  ? (g[t] = 0)
  : i.data[t] < e && 1 == s[t]
  ? ((g[t] = 0), (w = !0))
  : (g[t] = 1)
: ((g[t] = 0), (f[t] = 0));
for (let t = 0; t < g.length; t++) this.data[t] = g[t];
++u;
}
}),
(o.prototype.getCurrentNeighborhood = function(t, i) {
return (
((1 & t[i - 1]) << 7) |
((1 & t[i + 1]) << 3) |
((1 & t[i + this.width]) << 5) |
((1 & t[i - this.width]) << 1) |
(1 & t[i - (this.width + 1)]) |
((1 & t[i - (this.width - 1)]) << 2) |
((1 & t[i + (this.width - 1)]) << 6) |
((1 & t[i + (this.width + 1)]) << 4)
);
}),
(o.prototype.nbNeighbours = function(t) {
return (
(1 & t) +
((t >> 1) & 1) +
((t >> 2) & 1) +
((t >> 3) & 1) +
((t >> 4) & 1) +
((t >> 5) & 1) +
((t >> 6) & 1) +
((t >> 7) & 1)
);
}),
(o.prototype.getNbStrongNeighbors = function(t, i) {
return t[i - 1] + t[i + 1] + t[i - this.width] + t[i + this.width];
}),
(o.prototype.getNbNoStrongNeighbors = function(t, i) {
return (
t[i - 1 - this.width] +
t[i - 1 + this.width] +
t[i + 1 - this.width] +
t[i + 1 + this.width]
);
}),
(o.prototype.isInnerBoundaryPixel = function(t, i) {
return (
(1 == t[i] && 2 == t[i - 1]) ||
2 == t[i + 1] ||
2 == t[i - this.width] ||
2 == t[i + this.width]
);
}),
(o.prototype.isSimpleBoundaryPixel = function(t, i) {
let e = 0 != (1 & t[i + 1]),
h = 0 != (1 & t[i - this.width + 1]),
o = 0 != (1 & t[i - this.width]),
n = 0 != (1 & t[i - this.width - 1]),
s = 0 != (1 & t[i - 1]),
a = 0 != (1 & t[i + this.width - 1]),
r = 0 != (1 & t[i + this.width]),
d = 0 != (1 & t[i + this.width + 1]);
const g =
(1 - e) * h +
(1 - h) * o +
(1 - o) * n +
(1 - n) * s +
(1 - s) * a +
(1 - a) * r +
(1 - r) * d +
(1 - d) * e;
return (
(1 == g || (0 == g && 8 == e + h + o + n + s + a + r + d)) && (e || o || s || r)
);
});
var n = o,
s = function(t, i, e) {
(this.position = t), (this.weight = i), (this.neighbors = e || new Map());
};
(s.prototype.constructor = s),
(s.prototype.getPosition = function() {
return this.position;
}),
(s.prototype.getWeight = function() {
return this.weight;
}),
(s.prototype.getNeighbors = function() {
return this.neighbors;
}),
(s.prototype.setPosition = function(t) {
this.position = t;
}),
(s.prototype.setWeight = function(t) {
this.weight = t;
}),
(s.prototype.setNeighbors = function(t) {
this.neighbors = t;
});
var a = s,
r = function(t, i) {
(this.x = t), (this.y = i);
};
(r.prototype.distanceToOrigin = function(t) {
var i = this.x,
e = this.y;
return Math.sqrt(i * i + e * e);
}),
(r.prototype.distanceTo = function(t) {
var i = this.x - t.x,
e = this.y - t.y;
return Math.sqrt(i * i + e * e);
}),
(r.prototype.barycenter = function(t, i, e, h) {
var o = h / (e + h);
return (
(this.x = (1 - o) * t.x + o * i.x), (this.y = (1 - o) * t.y + o * i.y), this
);
});
var d = r,
g = function(t, i) {
(this.skelImg = t), (this.distImg = i);
};
(g.prototype.constructor = g),
(g.prototype.buildHierarchy = function() {
const t = this.skelImg.width * this.skelImg.height;
let i = {},
e = [],
h = this._findNextPixelWithNeighbors(this.skelImg, this.distImg, 0);
for (; h < t; ) {
if (void 0 === i[h]) {
const t = h % this.skelImg.width,
o = Math.round(h / this.skelImg.width);
(i[h] = new a(
new d(t + 0.5, o + 0.5),
this.distImg.data[h] / this.distImg.getCoeff()
)),
e.push(i[h]),
this._recHierarchy(i[h], h, this.skelImg, this.distImg, i);
}
h = this._findNextPixelWithNeighbors(this.skelImg, this.distImg, h + 1);
}
return e;
}),
(g.prototype._findNextPixelWithNeighbors = function(t, i, e) {
const h = t.width * t.height;
let o = e;
for (o = e; o < h; o++)
if (1 & t.data[o]) {
if (0 != t.getCurrentNeighborhood(t.data, o)) break;
t.data[o] = 0;
}
return o;
}),
(g.prototype._addNeighbors = function(t, i, e, h, o, n) {
const s = e % h,
r = Math.round(e / h);
let g = 0;
if (1 & i) {
if (void 0 === n[e - h - 1]) {
const t = new a(new d(s - 1 + 0.5, r - 1 + 0.5), o.data[e - h - 1]);
(n[e - h - 1] = t), g++;
}
t.neighbors.set(e - h - 1, n[e - h - 1]);
}
if (2 & i) {
if (void 0 === n[e - h]) {
const t = new a(new d(s + 0.5, r - 1 + 0.5), o.data[e - h]);
(n[e - h] = t), g++;
}
t.neighbors.set(e - h, n[e - h]);
}
if (4 & i) {
if (void 0 === n[e - h + 1]) {
const t = new a(new d(s + 1 + 0.5, r - 1 + 0.5), o.data[e - h + 1]);
(n[e - h + 1] = t), g++;
}
t.neighbors.set(e - h + 1, n[e - h + 1]);
}
if (8 & i) {
if (void 0 === n[e + 1]) {
const t = new a(new d(s + 1 + 0.5, r + 0.5), o.data[e + 1]);
(n[e + 1] = t), g++;
}
t.neighbors.set(e + 1, n[e + 1]);
}
if (16 & i) {
if (void 0 === n[e + h + 1]) {
const t = new a(new d(s + 1 + 0.5, r + 1 + 0.5), o.data[e + h + 1]);
(n[e + h + 1] = t), g++;
}
t.neighbors.set(e + h + 1, n[e + h + 1]);
}
if (32 & i) {
if (void 0 === n[e + h]) {
const t = new a(new d(s + 0.5, r + 1 + 0.5), o.data[e + h]);
(n[e + h] = t), g++;
}
t.neighbors.set(e + h, n[e + h]);
}
if (64 & i) {
if (void 0 === n[e + h - 1]) {
const t = new a(new d(s - 1 + 0.5, r + 1 + 0.5), o.data[e + h - 1]);
(n[e + h - 1] = t), g++;
}
t.neighbors.set(e + h - 1, n[e + h - 1]);
}
if (128 & i) {
if (void 0 === n[e - 1]) {
const t = new a(new d(s - 1 + 0.5, r + 0.5), o.data[e - 1]);
(n[e - 1] = t), g++;
}
t.neighbors.set(e - 1, n[e - 1]);
}
return g;
}),
(g.prototype._recHierarchy = function(t, i, e, h, o) {
const n = e.getCurrentNeighborhood(e.data, i);
if (this._addNeighbors(t, n, i, e.width, h, o))
for (let [i, n] of t.getNeighbors()) this._recHierarchy(n, i, e, h, o);
});
var f = g,
w = function(t, i, e, h, o) {
var n = new d(i.x - t.x, i.y - t.y),
s = n.distanceToOrigin();
(n.x = n.x / s), (n.y = n.y / s);
var a = new d(o.x - t.x, o.y - t.y),
r = a.distanceToOrigin(),
g = r * r,
f = a.x * n.x + a.y * n.y,
w = (f + (-Math.sqrt(Math.max(0, g - f * f)) / s) * (e - h)) / s;
w > 1 && (w = 1), w < 0 && (w = 0);
var u = new d(t.x, t.y);
return (
(u.x += (i.x - u.x) * w),
(u.y += (i.y - u.y) * w),
(u.z += (i.z - u.z) * w),
(a.x = o.x - u.x),
(a.y = o.y - u.y),
a.distanceToOrigin() - (w * h + (1 - w) * e)
);
},
u = function(t) {
this.distImg = t;
};
(u.prototype.constructor = u),
(u.prototype.buildHierarchy = function() {
var t = this;
const i = this.distImg.width,
e = this.distImg.height;
for (var h = {}, o = {}, n = [], s = new Array(i * e), r = 0; r < s.length; ++r)
s[r] = !1;
for (
var g = function(e, h, o) {
for (
var n = e.position.x,
a = e.position.y,
r = e.getPosition(),
g = Math.ceil(e.weight),
f = h ? Math.ceil(h.getWeight()) : 0,
u = h ? h.getPosition() : null,
y = new d(0, 0),
c = {
min: {
x: h ? Math.min(r.x - g, u.x - f) : r.x - g,
y: h ? Math.min(r.y - g, u.y - f) : r.y - g
},
max: {
x: h ? Math.max(r.x + g, u.x + f) : r.x + g,
y: h ? Math.max(r.y + g, u.y + f) : r.y + g
}
},
p = c.min.x;
p < c.max.x;
p++
)
for (var x = c.min.y; x < c.max.y; x++) {
(y.x = p), (y.y = x);
var l = h
? w(e.getPosition(), h.getPosition(), g, Math.ceil(h.weight), y)
: (p - n) * (p - n) + (x - a) * (x - a);
if (h ? l <= 0 : l <= g * g) (s[(M = x * i + p)] = !0), delete o[M];
}
for (
var I = 2 * Math.PI * (e.weight + 1), m = Math.round(I), v = 0;
v < m;
++v
) {
var b = (2 * v * Math.PI) / m,
M = ((p = Math.round(e.position.x + Math.cos(b) * (e.weight + 1))),
(x = Math.round(e.position.y + Math.sin(b) * (e.weight + 1))) * i + p),
N = t.distImg.getValue(p, x) / t.distImg.getCoeff();
!s[M] && N > 3 && (o[M] = e);
}
},
f = 0,
u = -1,
y = -1,
c = 0;
c < i;
++c
)
for (var p = 0; p < e; ++p) {
var x = this.distImg.getValue(c, p);
x > f && ((f = x), (u = c), (y = p));
}
var l = new a(new d(u, y), f / this.distImg.getCoeff());
(o[this.distImg.getIndex(u, y)] = l), n.push(l), g(l, null, h);
for (var I = 0, m = Object.keys(h); 0 !== m.length && I < 1e4; ) {
var v = -1,
b = 0;
for (r = 0; r < m.length; ++r) {
var M = parseInt(m[r]);
s[M]
? delete h[m[r]]
: this.distImg.getIndexValue(M) > b &&
  ((b = this.distImg.getIndexValue(M)), (v = M));
}
b /= this.distImg.getCoeff();
var N = new d(this.distImg.getXFromIndex(v), this.distImg.getYFromIndex(v)),
k = h[v],
P = {v: b, p: new d(N.x, N.y), idx: v};
(function() {
var i = k.getPosition().distanceTo(N),
e = new d(0, 0);
e.barycenter(N, k.getPosition(), 0.5, 0.5),
(e.x = Math.round(e.x)),
(e.y = Math.round(e.y));
var h = t.distImg.getValue(e.x, e.y) / t.distImg.getCoeff(),
o = new d(0, 0),
n = new d(N.x - k.getPosition().x, N.y - k.getPosition().y);
(n.x /= i), (n.y /= i);
for (
var s = new d(-n.y, n.x),
a = {v: h, p: new d(e.x, e.y), idx: v},
r = Math.max(k.getWeight() / 2, 3),
g = -r;
g <= r;
g++
) {
(o.x = Math.round(e.x + g * s.x)), (o.y = Math.round(e.y + g * s.y));
var f = t.distImg.getValue(o.x, o.y) / t.distImg.getCoeff();
f > a.v && f > h + 1.5 && ((a.v = f), (a.p.x = o.x), (a.p.y = o.y));
}
return (
(a.p.x !== e.x || a.p.y !== e.y) &&
((P.v = a.v),
(P.p.x = a.p.x),
(P.p.y = a.p.y),
(P.idx = t.distImg.getIndex(a.p.x, a.p.y)),
!0)
);
})() ||
(function() {
for (
var i = k.getPosition().distanceTo(N), e = new d(0, 0), h = 1;
h < i;
h += 1
) {
var o = h / i;
e.barycenter(N, k.getPosition(), 1 - o, o),
(e.x = Math.round(e.x)),
(e.y = Math.round(e.y));
var n = t.distImg.getValue(e.x, e.y) / t.distImg.getCoeff(),
s = h + b - n,
a = (1 - o) * b + o * k.weight;
s < 1 &&
n > a &&
((P.v = n),
(P.p.x = e.x),
(P.p.y = e.y),
(P.idx = t.distImg.getIndex(e.x, e.y)));
}
})();
var C = new a(P.p, P.v);
C.neighbors.set(this.distImg.getIndex(k.position.x, k.position.y), k),
k.neighbors.set(this.distImg.getIndex(C.position.x, C.position.y), C),
(o[P.idx] = C),
n.push(C),
delete h[v],
delete h[P.idx],
g(C, k, h),
(m = Object.keys(h)),
I++;
}
return {hierarchy: n, covered: s};
});
var y = u,
c = {};
return (
(c.BinaryImage = i),
(c.IntDistanceImage = h),
(c.SkeletonImage = n),
(c.Skeletonizer = f),
(c.skeletonize = function(t) {
var e = new i(t),
o = new h(3, 4, e, 0),
s = new n(e, 0, 2e3, o);
return {
skeleton: new f(s, o).buildHierarchy(),
binaryImg: e,
distImg: o,
skelImg: s
};
}),
(c.skeletonizeQ = function(t) {
var e = new i(t),
o = new h(3, 4, e, 0),
n = new y(o).buildHierarchy();
return {skeleton: n.hierarchy, binaryImg: e, distImg: o, covered: n.covered};
}),
(c.drawHierarchyInImageData = function(t, i) {
for (
var e = i,
h = {},
o = [],
n = function(t) {
var i = t.position.x + ";" + t.position.y;
void 0 === h[i] &&
((h[i] = t),
o.push(t),
t.getNeighbors().forEach(function(t, i, e) {
n(t);
}));
},
s = 0;
s < t.length;
++s
)
n(t[s]);
for (var a = 0; a < e.width; ++a)
for (var r = 0; r < e.height; ++r) {
var d = 0;
for (s = 0; s < o.length; ++s) {
var g = o[s].position.x + 0.5,
f = o[s].position.y + 0.5;
(a + 0.5 - g) * (a + 0.5 - g) + (r + 0.5 - f) * (r + 0.5 - f) <=
o[s].weight * o[s].weight && d++;
}
var w = 4 * (r * e.width + a);
e.data[w + 1] = (e.data[w + 1] + 255 * d) / (d + 1);
}
for (s = 0; s < o.length; ++s) {
var u = o[s];
w = 4 * (u.position.y * e.width + u.position.x);
(e.data[w] = 255), (e.data[w + 1] = 0), (e.data[w + 2] = 0);
}
return e;
}),
(c.drawCoverInImageData = function(t, i) {
for (var e = i, h = 0; h < e.width; ++h)
for (var o = 0; o < e.height; ++o) {
var n = o * e.width + h;
t[n] && ((n *= 4), (e.data[n + 1] = (e.data[n + 1] + 255) / 2));
}
return e;
}),
(c.drawHierarchyInCanvas = function(t, i) {
for (
var e = i.getContext("2d"),
h = {},
o = [],
n = function(t) {
var i = t.position.x + ";" + t.position.y;
void 0 === h[i] &&
((h[i] = t),
o.push(t),
t.getNeighbors().forEach(function(t, i, e) {
n(t);
}));
},
s = 0;
s < t.length;
++s
)
n(t[s]);
for (s = 0; s < o.length; ++s) {
var a = o[s];
a.getNeighbors().forEach(function(t, i, h) {
(e.strokeStyle = "#0000FF"),
e.beginPath(),
e.moveTo(a.position.x, a.position.y),
e.lineTo(t.position.x, t.position.y),
e.stroke();
});
}
}),
c
);
});
