!(function(t, i) {
"object" == typeof exports && "undefined" != typeof module
? (module.exports = i())
: "function" == typeof define && define.amd
? define(i)
: (t.ImageSkeletonizer = i());
})(this, function() {
"use strict";
var t = function(t, i) {
(this.tolerance = void 0 !== i ? i : 12),
(this.width = t.width),
(this.height = t.height),
(this.data = new Uint8Array(t.width * t.height)),
this._buildBinaryImage(t, this.tolerance);
};
(t.prototype.constructor = t),
(t.prototype.getIndex = function(t, i) {
return i * this.width + t;
}),
(t.prototype.getValue = function(t, i) {
return this.data[this.getIndex(t, i)];
}),
(t.prototype._buildBinaryImage = function(t, i) {
for (var e = this.width * this.height, h = 0; h < e; h++) {
var o = 4 * h;
t.data[o] < 125 && t.data[o + 1] < 125 && t.data[o + 2] < 125
? (this.data[h] = 1)
: (this.data[h] = 0);
}
});
var i = t,
e = function(t, e, h, o) {
if (!(h instanceof i))
throw "IntDistanceImage Error : source must be an instance of BinaryImage";
(this.coeff = t),
(this.width = h.width),
(this.height = h.height),
(this.data = new Array(h.width * h.height)),
this._buildDistanceImage(t, e, h, o);
};
(e.prototype.constructor = e),
(e.prototype.rebuild = function(t, i, e, h) {
(this.coeff = t), this._buildDistanceImage(t, i, e, h, this.data);
}),
(e.prototype.getCoeff = function() {
return this.coeff;
}),
(e.prototype.getIndex = function(t, i) {
return i * this.width + t;
}),
(e.prototype.getValue = function(t, i) {
return this.data[this.getIndex(t, i)];
}),
(e.prototype.getIndexValue = function(t) {
return this.data[t];
}),
(e.prototype.getXFromIndex = function(t) {
return t % this.width;
}),
(e.prototype.getYFromIndex = function(t) {
return Math.floor(t / this.width);
}),
(e.prototype._buildDistanceImage = function(t, i, e, h) {
const o = e.width,
n = e.height;
for (let t = 0; t < o; ++t) this.data[t] = 0;
for (let s = 1; s < n - 1; ++s) {
this.data[s * o] = 0;
for (let n = 1; n < o - 1; ++n) {
let o = this.getIndex(n, s);
this.data[o] = 0;
let r = 0;
if (e.data[o] != h) {
let e = this.getIndex(n - 1, s - 1),
h = this.getIndex(n, s - 1),
a = this.getIndex(n - 1, s),
d = this.getIndex(n + 1, s - 1);
(r = Math.min(this.data[e] + i, this.data[h] + t)),
(r = Math.min(r, this.data[a] + t)),
(r = Math.min(r, this.data[d] + i)),
(this.data[o] = r);
}
}
this.data[this.getIndex(o - 1, s)] = 0;
}
for (let t = 0; t < o; ++t) this.data[this.getIndex(t, n - 1)] = 0;
for (let s = n - 2; s > 0; --s)
for (let n = o - 2; n > 0; --n) {
let o = this.getIndex(n, s),
r = this.data[o];
if (e.data[o] != h) {
let e = this.getIndex(n + 1, s + 1),
h = this.getIndex(n, s + 1),
a = this.getIndex(n - 1, s + 1),
d = this.getIndex(n + 1, s);
(r = Math.min(r, this.data[e] + i)),
(r = Math.min(r, this.data[h] + t)),
(r = Math.min(r, this.data[a] + i)),
(this.data[o] = Math.min(r, this.data[d] + t));
}
}
}),
(e.prototype.getImageData = function(t) {
var i = new ImageData(this.width, this.height);
let e = 0;
for (let t = 0; t < this.width * this.height; t++)
e = this.data[t] > e ? this.data[t] : e;
for (let t = 0, h = 0, o = 0; t < this.height; t++)
for (let n = 0; n < this.width; n++) {
let s = t * this.width + n;
this.data[s] > 3
? ((o = (255 * this.data[s]) / e),
  (i.data[h] = o),
  (i.data[h + 1] = o),
  (i.data[h + 2] = o),
  (i.data[h + 3] = 255))
: ((i.data[h] = 255),
  (i.data[h + 1] = 255),
  (i.data[h + 2] = 255),
  (i.data[h + 3] = 255)),
(h += 4);
}
return i;
});
var h = e,
o = function(t, i, e, h) {
(this.width = t.width),
(this.height = t.height),
(this.data = new Array(this.width * this.height));
for (let e = 0; e < this.width * this.height; e++)
t.data[e] != i ? (this.data[e] = 1) : (this.data[e] = 0);
let o = 0;
for (let t = 0; t < h.width * h.height; t++) o = h.data[t] > o ? h.data[t] : o;
this.CleanBorderPixels(),
this.skeletonizeEckhardtMaderlechner93(e, h, 0.8 * o),
this.CleanBorderPixels(),
this.thin();
};
(o.prototype.constructor = o),
(o.prototype.getIndex = function(t, i) {
return i * this.width + t;
}),
(o.prototype.getXFromIndex = function(t) {
return t % this.width;
}),
(o.prototype.getYFromIndex = function(t) {
return Math.floor(t / this.width);
}),
(o.prototype.getImageData = function(t, i) {
var e = new ImageData(this.width, this.height),
h = t || [255, 255, 255, 255],
o = i || [255, 0, 0, 255];
let n = 0;
for (let t = 0; t < this.width * this.height; t++)
n = this.data[t] > n ? this.data[t] : n;
for (let t = 0, i = 0; t < this.height; t++)
for (let n = 0; n < this.width; n++) {
let s = t * this.width + n;
1 === this.data[s]
? ((e.data[i] = o[0]),
  (e.data[i + 1] = o[1]),
  (e.data[i + 2] = o[2]),
  (e.data[i + 3] = o[3]))
: ((e.data[i] = h[0]),
  (e.data[i + 1] = h[1]),
  (e.data[i + 2] = h[2]),
  (e.data[i + 3] = h[3])),
(i += 4);
}
return e;
}),
(o.prototype.CleanBorderPixels = function() {
for (let t = 0; t < this.width; t++)
(this.data[t] = 0), (this.data[(this.height - 1) * this.width + t] = 0);
for (let t = 1; t < this.height - 2; t++)
(this.data[t * this.width] = 0),
(this.data[t * this.width + (this.width - 1)] = 0);
}),
(o.prototype.thin = function() {
let t = this.width - 2;
for (let i = 1; i < this.height - 1; i++) {
t += 2;
for (let i = 1; i < this.width - 1; i++) {
if ((t++, 0 == (1 & this.data[t]))) continue;
const i = this.getCurrentNeighborhood(t);
((0 == (7 & i) && 112 == (112 & i)) ||
(0 == (14 & i) && 160 == (160 & i)) ||
(0 == (28 & i) && 193 == (193 & i)) ||
(0 == (56 & i) && 130 == (130 & i)) ||
(0 == (112 & i) && 7 == (7 & i)) ||
(0 == (224 & i) && 10 == (10 & i)) ||
(0 == (193 & i) && 28 == (28 & i)) ||
(0 == (131 & i) && 40 == (40 & i))) &&
(this.data[t] = 0);
}
}
return this.data;
}),
(o.prototype.skeletonizeEckhardtMaderlechner93 = function(t, i, e) {
const h = this.width * this.height,
o = new Array(this.width * this.height),
n = new Array(this.width * this.height),
s = new Array(this.width * this.height),
r = new Array(this.width * this.height),
a = new Array(this.width * this.height),
d = new Array(this.width * this.height),
g = new Array(this.width * this.height),
f = new Array(this.width * this.height);
let u = !0,
y = 0;
const c = this.width + 1,
l = h - this.width - 1;
for (; u && y < t; ) {
u = !1;
for (let t = c; t < l; t++)
(n[t] = this.getNbStrongNeighbors(this.data, t)),
(s[t] = n[t] + this.getNbNoStrongNeighbors(this.data, t)),
this.data[t]
? 4 == n[t]
  ? ((o[t] = 2), (f[t] = 1))
  : ((o[t] = 1), (f[t] = 2))
: (o[t] = 0);
for (let t = c; t < l; t++)
this.data[t]
? (r[t] =
  1 == o[t] &&
  (2 == o[t + 1] ||
  2 == o[t - 1] ||
  2 == o[t + this.width] ||
  2 == o[t - this.width]))
: (r[t] = !1),
r[t] ? ((r[t] = 1), (f[t] = 3)) : (r[t] = 0);
for (let t = c; t < l; ++t) {
if (this.data[t] && 1 == o[t]) {
let i = 0 != (1 & this.data[t + 1]),
e = 0 != (1 & this.data[t - this.width + 1]),
h = 0 != (1 & this.data[t - this.width]),
n = 0 != (1 & this.data[t - this.width - 1]),
s = 0 != (1 & this.data[t - 1]),
r = 0 != (1 & this.data[t + this.width - 1]),
a = 0 != (1 & this.data[t + this.width]),
g = 0 != (1 & this.data[t + this.width + 1]);
const f =
(1 - i) * e +
(1 - e) * h +
(1 - h) * n +
(1 - n) * s +
(1 - s) * r +
(1 - r) * a +
(1 - a) * g +
(1 - g) * i,
u = i + e + h + n + s + r + a + g,
y = 1 == f || (0 == f && 8 == u);
d[t] = 1 == o[t] && y && (i || h || s || a);
} else d[t] = !1;
d[t] && (f[t] = 4);
}
for (let t = c; t < l; ++t) {
if (this.data[t]) {
const i = 2 == o[t + 1] && !this.data[t - 1],
e = 2 == o[t - 1] && !this.data[t + 1],
h = 2 == o[t + this.width] && !this.data[t - this.width],
n = 2 == o[t - this.width] && !this.data[t + this.width];
a[t] = r[t] && (i || e || h || n);
} else a[t] = !1;
a[t] && (f[t] = 5);
}
for (let t = 0; t < h; ++t)
this.data[t]
? d[t] && a[t]
  ? ((g[t] = 0), (f[t] = 6), (u = !0))
  : 0 == s[t]
  ? (g[t] = 0)
  : i.data[t] < e && 1 == s[t]
  ? ((g[t] = 0), (u = !0))
  : (g[t] = 1)
: ((g[t] = 0), (f[t] = 0));
for (let t = 0; t < g.length; t++) this.data[t] = g[t];
++y;
}
}),
(o.prototype.getCurrentNeighborhood = function(t) {
var i = this.data;
return (
((1 & i[t - 1]) << 7) |
((1 & i[t + 1]) << 3) |
((1 & i[t + this.width]) << 5) |
((1 & i[t - this.width]) << 1) |
(1 & i[t - (this.width + 1)]) |
((1 & i[t - (this.width - 1)]) << 2) |
((1 & i[t + (this.width - 1)]) << 6) |
((1 & i[t + (this.width + 1)]) << 4)
);
}),
(o.prototype.nbNeighbours = function(t) {
return (
(1 & t) +
((t >> 1) & 1) +
((t >> 2) & 1) +
((t >> 3) & 1) +
((t >> 4) & 1) +
((t >> 5) & 1) +
((t >> 6) & 1) +
((t >> 7) & 1)
);
}),
(o.prototype.getNbStrongNeighbors = function(t, i) {
return t[i - 1] + t[i + 1] + t[i - this.width] + t[i + this.width];
}),
(o.prototype.getNbNoStrongNeighbors = function(t, i) {
return (
t[i - 1 - this.width] +
t[i - 1 + this.width] +
t[i + 1 - this.width] +
t[i + 1 + this.width]
);
}),
(o.prototype.isInnerBoundaryPixel = function(t, i) {
return (
(1 == t[i] && 2 == t[i - 1]) ||
2 == t[i + 1] ||
2 == t[i - this.width] ||
2 == t[i + this.width]
);
}),
(o.prototype.isSimpleBoundaryPixel = function(t, i) {
let e = 0 != (1 & t[i + 1]),
h = 0 != (1 & t[i - this.width + 1]),
o = 0 != (1 & t[i - this.width]),
n = 0 != (1 & t[i - this.width - 1]),
s = 0 != (1 & t[i - 1]),
r = 0 != (1 & t[i + this.width - 1]),
a = 0 != (1 & t[i + this.width]),
d = 0 != (1 & t[i + this.width + 1]);
const g =
(1 - e) * h +
(1 - h) * o +
(1 - o) * n +
(1 - n) * s +
(1 - s) * r +
(1 - r) * a +
(1 - a) * d +
(1 - d) * e;
return (
(1 == g || (0 == g && 8 == e + h + o + n + s + r + a + d)) && (e || o || s || a)
);
});
var n = o,
s = function(t, i) {
(this.position = t), (this.weight = i), (this.neighbors = new Map());
};
(s.computeKey = function(t, i) {
return Math.floor(t) + ";" + Math.floor(i);
}),
(s.getXYFromKey = function(t) {
var i = t.split(";");
return (i[0] = parseInt(i[0])), (i[1] = parseInt(i[1])), i;
}),
(s.prototype.constructor = s),
(s.prototype.getKey = function() {
return s.computeKey(this.position.x, this.position.y);
}),
(s.prototype.getPosition = function() {
return this.position;
}),
(s.prototype.getWeight = function() {
return this.weight;
}),
(s.prototype.getNeighbors = function() {
return this.neighbors;
}),
(s.prototype.setPosition = function(t) {
this.position = t;
}),
(s.prototype.setWeight = function(t) {
this.weight = t;
}),
(s.prototype.setNeighbors = function(t) {
this.neighbors = t;
}),
(s.prototype.addNeighbor = function(t) {
this.neighbors.set(t.getKey(), t), t.neighbors.set(this.getKey(), this);
}),
(s.prototype.removeNeighbor = function(t) {
this.neighbors.delete(t.getKey()), t.neighbors.delete(this.getKey());
}),
(s.prototype.hasNeighbor = function(t) {
return this.neighbors.has(t.getKey());
});
var r = s,
a = function(t, i) {
(this.x = t), (this.y = i);
};
(a.prototype.distanceToOrigin = function(t) {
var i = this.x,
e = this.y;
return Math.sqrt(i * i + e * e);
}),
(a.prototype.distanceTo = function(t) {
var i = this.x - t.x,
e = this.y - t.y;
return Math.sqrt(i * i + e * e);
}),
(a.prototype.barycenter = function(t, i, e, h) {
var o = h / (e + h);
return (
(this.x = (1 - o) * t.x + o * i.x), (this.y = (1 - o) * t.y + o * i.y), this
);
});
var d = a,
g = function(t, i) {
(this.x = t || 0), (this.y = i || 0);
};
(g.prototype.length = function(t) {
var i = this.x,
e = this.y;
return Math.sqrt(i * i + e * e);
}),
(g.prototype.subPoints = function(t, i) {
return (this.x = t.x - i.x), (this.y = t.y - i.y), this;
}),
(g.prototype.angle = function() {
var t = Math.atan2(this.y, this.x);
return t < 0 && (t += 2 * Math.PI), t;
});
var f = g,
u = function(t, i) {
(this.skelImg = t), (this.distImg = i);
};
(u.prototype.constructor = u),
(u.prototype.buildHierarchy = function(t) {
((t = t || {}).angle = t.angle || Math.PI / 13),
(t.weightFactor = t.weightFactor || 1.25);
const i = this.skelImg.width * this.skelImg.height;
let e = {},
h = [],
o = this._findNextPixelWithNeighbors(0);
for (; o < i; ) {
const t = this.skelImg.getXFromIndex(o),
i = this.skelImg.getYFromIndex(o);
var n = r.computeKey(t + 0.5, i + 0.5);
void 0 === e[n] &&
((e[n] = new r(
new d(t + 0.5, i + 0.5),
this.distImg.data[o] / this.distImg.getCoeff()
)),
h.push(e[n]),
this._recHierarchy(e[n], e)),
(o = this._findNextPixelWithNeighbors(o + 1));
}
return this._simplifyHierarchy(h, t.angle, t.weightFactor);
}),
(u.prototype._simplifyHierarchy = function(t, i, e) {
if (e < 1)
throw "weight_factor must be greater than 1 as it compares weight_max and weight_factor*weight_min";
for (
var h = function(t, o) {
for (
var n = new f(),
r = o,
a = new f(),
d = r.getNeighbors().size,
g = !0,
u = !0,
y = null,
c = 0;
2 === d && g && u && !s[r.getKey()];

) {
var l = r.getNeighbors().keys();
(y = r),
(r = r.getNeighbors().get(l.next().value)) === t &&
(r = y.getNeighbors().get(l.next().value));
c < 3 && ((a.x += r.getPosition().x), (a.y += r.getPosition().y)),
2 === c &&
((a.x = (a.x - 3 * t.getPosition().x) / 3),
(a.y = (a.y - 3 * t.getPosition().y) / 3)),
c++,
n.subPoints(r.getPosition(), t.getPosition());
var p = n.angle() - a.angle();
if ((Math.abs(p) < i || c < 3 || (g = !1), c >= 3)) {
var w = t.getWeight() / r.getWeight();
w < 1 && (w = 1 / w), w > e && (u = !1);
}
g && u && (t.removeNeighbor(y), r.removeNeighbor(y), t.addNeighbor(r)),
(s[y.getKey()] = !0),
(d = r.getNeighbors().size);
}
if (!s[r.getKey()])
if (1 === d)
(g && u) || (y && y.removeNeighbor(r)),
0 === c && t.removeNeighbor(r),
(s[r.getKey()] = !0);
else if (2 === d) h(y, r), (s[y.getKey()] = !0);
else {
var x = [];
if (
(r.getNeighbors().forEach(function(i, e, h) {
i !== y && i !== t && x.push(i);
}),
!g || !u)
) {
y.removeNeighbor(r);
for (var I = 0; I < x.length; ++I) r.removeNeighbor[x[I]], y.addNeighbor[x[I]];
r = y;
}
s[r.getKey()] = !0;
var m = new Map();
for (I = 0; I < x.length; ++I) {
for (var v = I + 1; v < x.length; ++v) x[I].removeNeighbor(x[v]);
x[I].getNeighbors().forEach(function(t, i, e) {
m.set(i, t);
});
}
m.delete(r.getKey());
var b = new f();
m.forEach(function(t, i, e) {
for (var h = 0, o = 0; o < x.length; ++o) t.hasNeighbor(x[o]) && h++;
if (h > 1)
for (o = 0; o < x.length; ++o)
t.hasNeighbor(x[o]) &&
(b.subPoints(t.getPosition(), x[o].getPosition()),
b.length() > 1 && t.removeNeighbor(x[o]));
});
for (I = 0; I < x.length; ++I) h(r, x[I]);
}
},
o = 0;
o < t.length;
++o
) {
var n = t[o],
s = {};
s[n.getKey()] = !0;
n.getNeighbors().get(
n
.getNeighbors()
.keys()
.next().value
);
if (n.getNeighbors().size > 1) throw "Hoho... Should not happen";
h(
n,
n.getNeighbors().get(
n
.getNeighbors()
.keys()
.next().value
)
);
}
return t;
}),
(u.prototype._findNextPixelWithNeighbors = function(t) {
const i = this.skelImg.width * this.skelImg.height;
let e = t;
for (e = t; e < i; e++)
if (1 & this.skelImg.data[e]) {
if (0 != this.skelImg.getCurrentNeighborhood(e)) break;
this.skelImg.data[e] = 0;
}
return e;
}),
(u.prototype._checkAndCreate = function(t, i, e, h) {
var o = r.computeKey(t + 0.5, i + 0.5),
n = !1;
return (
void 0 === h[o] &&
((h[o] = new r(
new d(t + 0.5, i + 0.5),
this.distImg.getValue(t, i) / this.distImg.getCoeff()
)),
(n = !0)),
e.neighbors.set(o, h[o]),
n
);
}),
(u.prototype._addNeighbors = function(t, i, e) {
this.skelImg.width;
const h = Math.floor(t.position.x),
o = Math.floor(t.position.y);
let n = 0;
return (
1 & i && (n += this._checkAndCreate(h - 1, o - 1, t, e) ? 1 : 0),
2 & i && (n += this._checkAndCreate(h, o - 1, t, e) ? 1 : 0),
4 & i && (n += this._checkAndCreate(h + 1, o - 1, t, e) ? 1 : 0),
8 & i && (n += this._checkAndCreate(h + 1, o, t, e) ? 1 : 0),
16 & i && (n += this._checkAndCreate(h + 1, o + 1, t, e) ? 1 : 0),
32 & i && (n += this._checkAndCreate(h, o + 1, t, e) ? 1 : 0),
64 & i && (n += this._checkAndCreate(h - 1, o + 1, t, e) ? 1 : 0),
128 & i && (n += this._checkAndCreate(h - 1, o, t, e) ? 1 : 0),
n
);
}),
(u.prototype._addNeighborsOLD = function(t, i, e, h) {
const o = this.skelImg.width,
n = e % o,
s = Math.round(e / o);
let a = 0;
if (1 & i) {
if (void 0 === h[e - o - 1]) {
const t = new r(
new d(n - 1 + 0.5, s - 1 + 0.5),
this.distImg.getIndexValue(e - o - 1)
);
(h[e - o - 1] = t), a++;
}
t.neighbors.set(e - o - 1, h[e - o - 1]);
}
if (2 & i) {
if (void 0 === h[e - o]) {
const t = new r(new d(n + 0.5, s - 1 + 0.5), this.distImg.getIndexValue(e - o));
(h[e - o] = t), a++;
}
t.neighbors.set(e - o, h[e - o]);
}
if (4 & i) {
if (void 0 === h[e - o + 1]) {
const t = new r(
new d(n + 1 + 0.5, s - 1 + 0.5),
this.distImg.getIndexValue(e - o + 1)
);
(h[e - o + 1] = t), a++;
}
t.neighbors.set(e - o + 1, h[e - o + 1]);
}
if (8 & i) {
if (void 0 === h[e + 1]) {
const t = new r(new d(n + 1 + 0.5, s + 0.5), this.distImg.getIndexValue(e + 1));
(h[e + 1] = t), a++;
}
t.neighbors.set(e + 1, h[e + 1]);
}
if (16 & i) {
if (void 0 === h[e + o + 1]) {
const t = new r(
new d(n + 1 + 0.5, s + 1 + 0.5),
this.distImg.getIndexValue(e + o + 1)
);
(h[e + o + 1] = t), a++;
}
t.neighbors.set(e + o + 1, h[e + o + 1]);
}
if (32 & i) {
if (void 0 === h[e + o]) {
const t = new r(new d(n + 0.5, s + 1 + 0.5), this.distImg.getIndexValue(e + o));
(h[e + o] = t), a++;
}
t.neighbors.set(e + o, h[e + o]);
}
if (64 & i) {
if (void 0 === h[e + o - 1]) {
const t = new r(
new d(n - 1 + 0.5, s + 1 + 0.5),
this.distImg.getIndexValue(e + o - 1)
);
(h[e + o - 1] = t), a++;
}
t.neighbors.set(e + o - 1, h[e + o - 1]);
}
if (128 & i) {
if (void 0 === h[e - 1]) {
const t = new r(new d(n - 1 + 0.5, s + 0.5), this.distImg.getIndexValue(e - 1));
(h[e - 1] = t), a++;
}
t.neighbors.set(e - 1, h[e - 1]);
}
return a;
}),
(u.prototype._recHierarchy = function(t, i) {
const e = this.skelImg.getCurrentNeighborhood(
this.skelImg.getIndex(Math.floor(t.position.x), Math.floor(t.position.y))
);
if (this._addNeighbors(t, e, i))
for (let [e, h] of t.getNeighbors()) this._recHierarchy(h, i);
});
var y,
c,
l,
p = u,
w = ((y = new f()),
(c = new f()),
(l = new d()),
function(t, i, e, h, o) {
(y.x = i.x - t.x), (y.y = i.y - t.y);
var n = y.length();
(y.x = y.x / n), (y.y = y.y / n), c.subPoints(o, t);
var s = c.length(),
r = s * s,
a = c.x * y.x + c.y * y.y,
d = (a + (-Math.sqrt(Math.max(0, r - a * a)) / n) * (e - h)) / n;
return (
d > 1 && (d = 1),
d < 0 && (d = 0),
(l.x = t.x),
(l.y = t.y),
(l.x += (i.x - l.x) * d),
(l.y += (i.y - l.y) * d),
(l.z += (i.z - l.z) * d),
(c.x = o.x - l.x),
(c.y = o.y - l.y),
c.length() - (d * h + (1 - d) * e)
);
}),
x = function(t) {
this.distImg = t;
};
(x.prototype.constructor = x),
(x.prototype.buildHierarchy = function() {
var t = this;
const i = this.distImg.width,
e = this.distImg.height;
for (var h = {}, o = {}, n = [], s = new Array(i * e), a = 0; a < s.length; ++a)
s[a] = !1;
for (
var g = function(e, h, o) {
for (
var n = e.position.x,
r = e.position.y,
a = e.getPosition(),
g = Math.ceil(e.weight),
f = h ? Math.ceil(h.getWeight()) : 0,
u = h ? h.getPosition() : null,
y = new d(0, 0),
c = {
min: {
x: h ? Math.min(a.x - g, u.x - f) : a.x - g,
y: h ? Math.min(a.y - g, u.y - f) : a.y - g
},
max: {
x: h ? Math.max(a.x + g, u.x + f) : a.x + g,
y: h ? Math.max(a.y + g, u.y + f) : a.y + g
}
},
l = c.min.x;
l < c.max.x;
l++
)
for (var p = c.min.y; p < c.max.y; p++) {
(y.x = l), (y.y = p);
var x = h
? w(e.getPosition(), h.getPosition(), g, Math.ceil(h.weight), y)
: (l - n) * (l - n) + (p - r) * (p - r);
if (h ? x <= 0 : x <= g * g) (s[(N = p * i + l)] = !0), delete o[N];
}
for (
var I = 2 * Math.PI * (e.weight + 1), m = Math.round(I), v = 0;
v < m;
++v
) {
var b = (2 * v * Math.PI) / m,
N = ((l = Math.round(e.position.x + Math.cos(b) * (e.weight + 1))),
(p = Math.round(e.position.y + Math.sin(b) * (e.weight + 1))) * i + l),
M = t.distImg.getValue(l, p) / t.distImg.getCoeff();
!s[N] && M > 3 && (o[N] = e);
}
},
f = 0,
u = -1,
y = -1,
c = 0;
c < i;
++c
)
for (var l = 0; l < e; ++l) {
var p = this.distImg.getValue(c, l);
p > f && ((f = p), (u = c), (y = l));
}
var x = new r(new d(u, y), f / this.distImg.getCoeff());
(o[this.distImg.getIndex(u, y)] = x), n.push(x), g(x, null, h);
for (var I = 0, m = Object.keys(h); 0 !== m.length && I < 1e4; ) {
var v = -1,
b = 0;
for (a = 0; a < m.length; ++a) {
var N = parseInt(m[a]);
s[N]
? delete h[m[a]]
: this.distImg.getIndexValue(N) > b &&
  ((b = this.distImg.getIndexValue(N)), (v = N));
}
b /= this.distImg.getCoeff();
var M = new d(this.distImg.getXFromIndex(v), this.distImg.getYFromIndex(v)),
k = h[v],
P = {v: b, p: new d(M.x, M.y), idx: v};
(function() {
var i = k.getPosition().distanceTo(M),
e = new d(0, 0);
e.barycenter(M, k.getPosition(), 0.5, 0.5),
(e.x = Math.round(e.x)),
(e.y = Math.round(e.y));
var h = t.distImg.getValue(e.x, e.y) / t.distImg.getCoeff(),
o = new d(0, 0),
n = new d(M.x - k.getPosition().x, M.y - k.getPosition().y);
(n.x /= i), (n.y /= i);
for (
var s = new d(-n.y, n.x),
r = {v: h, p: new d(e.x, e.y), idx: v},
a = Math.max(k.getWeight() / 2, 3),
g = -a;
g <= a;
g++
) {
(o.x = Math.round(e.x + g * s.x)), (o.y = Math.round(e.y + g * s.y));
var f = t.distImg.getValue(o.x, o.y) / t.distImg.getCoeff();
f > r.v && f > h + 1.5 && ((r.v = f), (r.p.x = o.x), (r.p.y = o.y));
}
return (
(r.p.x !== e.x || r.p.y !== e.y) &&
((P.v = r.v),
(P.p.x = r.p.x),
(P.p.y = r.p.y),
(P.idx = t.distImg.getIndex(r.p.x, r.p.y)),
!0)
);
})() ||
(function() {
for (
var i = k.getPosition().distanceTo(M), e = new d(0, 0), h = 1;
h < i;
h += 1
) {
var o = h / i;
e.barycenter(M, k.getPosition(), 1 - o, o),
(e.x = Math.round(e.x)),
(e.y = Math.round(e.y));
var n = t.distImg.getValue(e.x, e.y) / t.distImg.getCoeff(),
s = h + b - n,
r = (1 - o) * b + o * k.weight;
s < 1 &&
n > r &&
((P.v = n),
(P.p.x = e.x),
(P.p.y = e.y),
(P.idx = t.distImg.getIndex(e.x, e.y)));
}
})();
var _ = new r(P.p, P.v);
_.neighbors.set(this.distImg.getIndex(k.position.x, k.position.y), k),
k.neighbors.set(this.distImg.getIndex(_.position.x, _.position.y), _),
(o[P.idx] = _),
n.push(_),
delete h[v],
delete h[P.idx],
g(_, k, h),
(m = Object.keys(h)),
I++;
}
return {hierarchy: n, covered: s};
});
var I = x,
m = {};
return (
(m.BinaryImage = i),
(m.IntDistanceImage = h),
(m.SkeletonImage = n),
(m.Skeletonizer = p),
(m.skeletonize = function(t, e, o) {
var s = new i(t),
r = new h(3, 4, s, 0),
a = new n(s, 0, 2e3, r);
return {
skeleton: new p(a, r).buildHierarchy({
angle: e || void 0,
weightFactor: o || void 0
}),
binaryImg: s,
distImg: r,
skelImg: a
};
}),
(m.skeletonizeQ = function(t) {
var e = new i(t),
o = new h(3, 4, e, 0),
n = new I(o).buildHierarchy();
return {skeleton: n.hierarchy, binaryImg: e, distImg: o, covered: n.covered};
}),
(m.drawHierarchyInImageData = function(t, i) {
for (
var e = i,
h = {},
o = [],
n = function(t) {
var i = t.position.x + ";" + t.position.y;
void 0 === h[i] &&
((h[i] = t),
o.push(t),
t.getNeighbors().forEach(function(t, i, e) {
n(t);
}));
},
s = 0;
s < t.length;
++s
)
n(t[s]);
for (var r = 0; r < e.width; ++r)
for (var a = 0; a < e.height; ++a) {
var d = 0;
for (s = 0; s < o.length; ++s) {
var g = o[s].position.x + 0.5,
f = o[s].position.y + 0.5;
(r + 0.5 - g) * (r + 0.5 - g) + (a + 0.5 - f) * (a + 0.5 - f) <=
o[s].weight * o[s].weight && d++;
}
var u = 4 * (a * e.width + r);
e.data[u + 1] = (e.data[u + 1] + 255 * d) / (d + 1);
}
for (s = 0; s < o.length; ++s) {
var y = o[s];
u = 4 * (Math.floor(y.position.y) * e.width + Math.floor(y.position.x));
(e.data[u] = 255), (e.data[u + 1] = 0), (e.data[u + 2] = 0);
}
return e;
}),
(m.drawCoverInImageData = function(t, i) {
for (var e = i, h = 0; h < e.width; ++h)
for (var o = 0; o < e.height; ++o) {
var n = o * e.width + h;
t[n] && ((n *= 4), (e.data[n + 1] = (e.data[n + 1] + 255) / 2));
}
return e;
}),
(m.drawHierarchyInCanvas = function(t, i) {
for (
var e = i.getContext("2d"),
h = {},
o = [],
n = function(t) {
var i = t.position.x + ";" + t.position.y;
void 0 === h[i] &&
((h[i] = t),
o.push(t),
t.getNeighbors().forEach(function(t, i, e) {
n(t);
}));
},
s = 0;
s < t.length;
++s
)
n(t[s]);
for (s = 0; s < o.length; ++s) {
var r = o[s];
r.getNeighbors().forEach(function(t, i, h) {
(e.lineWidth = 1),
(e.strokeStyle = "#ff0000"),
e.beginPath(),
e.moveTo(r.position.x, r.position.y),
e.lineTo(t.position.x, t.position.y),
e.stroke(),
(e.fillStyle = "#0000ff"),
e.fillRect(r.position.x, r.position.y, 1, 1),
e.fillRect(t.position.x, t.position.y, 1, 1);
});
}
}),
m
);
});
