!(function(t, i) {
"object" == typeof exports && "undefined" != typeof module
? (module.exports = i())
: "function" == typeof define && define.amd
? define(i)
: (t.ImageSkeletonizer = i());
})(this, function() {
"use strict";
var t = function(t, i) {
(this.tolerance = void 0 !== i ? i : 12),
(this.width = t.width),
(this.height = t.height),
(this.data = new Uint8Array(t.width * t.height)),
this._buildBinaryImage(t, this.tolerance);
};
(t.prototype.constructor = t),
(t.prototype.getIndex = function(t, i) {
return i * this.width + t;
}),
(t.prototype.getValue = function(t, i) {
return this.data[this.getIndex(t, i)];
}),
(t.prototype._buildBinaryImage = function(t, i) {
for (var h = this.width * this.height, e = 0; e < h; e++) {
var s = 4 * e;
t.data[s] < 125 && t.data[s + 1] < 125 && t.data[s + 2] < 125
? (this.data[e] = 1)
: (this.data[e] = 0);
}
});
var i = t,
h = function(t, h, e, s) {
if (!(e instanceof i))
throw "IntDistanceImage Error : source must be an instance of BinaryImage";
(this.coeff = t),
(this.width = e.width),
(this.height = e.height),
(this.data = new Array(e.width * e.height)),
this._buildDistanceImage(t, h, e, s);
};
(h.prototype.constructor = h),
(h.prototype.rebuild = function(t, i, h, e) {
(this.coeff = t), this._buildDistanceImage(t, i, h, e, this.data);
}),
(h.prototype.getCoeff = function() {
return this.coeff;
}),
(h.prototype.getIndex = function(t, i) {
return i * this.width + t;
}),
(h.prototype.getValue = function(t, i) {
return this.data[this.getIndex(t, i)];
}),
(h.prototype._buildDistanceImage = function(t, i, h, e) {
const s = h.width,
a = h.height;
for (let t = 0; t < s; ++t) this.data[t] = 0;
for (let n = 1; n < a - 1; ++n) {
this.data[n * s] = 0;
for (let a = 1; a < s - 1; ++a) {
let s = this.getIndex(a, n);
this.data[s] = 0;
let o = 0;
if (h.data[s] != e) {
let h = this.getIndex(a - 1, n - 1),
e = this.getIndex(a, n - 1),
r = this.getIndex(a - 1, n),
d = this.getIndex(a + 1, n - 1);
(o = Math.min(this.data[h] + i, this.data[e] + t)),
(o = Math.min(o, this.data[r] + t)),
(o = Math.min(o, this.data[d] + i)),
(this.data[s] = o);
}
}
this.data[this.getIndex(s - 1, n)] = 0;
}
for (let t = 0; t < s; ++t) this.data[this.getIndex(t, a - 1)] = 0;
for (let n = a - 2; n > 0; --n)
for (let a = s - 2; a > 0; --a) {
let s = this.getIndex(a, n),
o = this.data[s];
if (h.data[s] != e) {
let h = this.getIndex(a + 1, n + 1),
e = this.getIndex(a, n + 1),
r = this.getIndex(a - 1, n + 1),
d = this.getIndex(a + 1, n);
(o = Math.min(o, this.data[h] + i)),
(o = Math.min(o, this.data[e] + t)),
(o = Math.min(o, this.data[r] + i)),
(this.data[s] = Math.min(o, this.data[d] + t));
}
}
}),
(h.prototype.toGreyScale = function(t, i) {
let h = new Uint8ClampedArray(this.width * this.height * 4),
e = 0;
for (let t = 0; t < this.width * this.height; t++)
e = this.data[t] > e ? this.data[t] : e;
for (let t = 0, s = 0, a = 0; t < this.height; t++)
for (let n = 0; n < this.width; n++) {
let o = t * this.width + n;
1 == i.data[o]
? ((h[s] = 255), (h[s + 1] = 0), (h[s + 2] = 0), (h[s + 3] = 255))
: this.data[o] > 3
? ((a = (255 * this.data[o]) / e),
  (h[s] = a),
  (h[s + 1] = a),
  (h[s + 2] = a),
  (h[s + 3] = 255))
: ((h[s] = 255), (h[s + 1] = 255), (h[s + 2] = 255), (h[s + 3] = 255)),
(s += 4);
}
let s = t.createImageData(this.width, this.height);
return s.data.set(h), s;
});
var e = h,
s = function(t, i, h, e) {
(this.width = t.width),
(this.height = t.height),
(this.data = new Array(this.width * this.height));
for (let h = 0; h < this.width * this.height; h++)
t.data[h] != i ? (this.data[h] = 1) : (this.data[h] = 0);
let s = 0;
for (let t = 0; t < e.width * e.height; t++) s = e.data[t] > s ? e.data[t] : s;
this.CleanBorderPixels(),
this.skeletonizeEckhardtMaderlechner93(h, e, 0.8 * s),
this.CleanBorderPixels(),
this.thin();
};
(s.prototype.constructor = s),
(s.prototype.getImageData = function(t, i) {
var h = new ImageData(this.width, this.height),
e = t || [255, 255, 255, 255],
s = i || [255, 0, 0, 255];
let a = 0;
for (let t = 0; t < this.width * this.height; t++)
a = this.data[t] > a ? this.data[t] : a;
for (let t = 0, i = 0; t < this.height; t++)
for (let a = 0; a < this.width; a++) {
let n = t * this.width + a;
1 === this.data[n]
? ((h.data[i] = s[0]),
  (h.data[i + 1] = s[1]),
  (h.data[i + 2] = s[2]),
  (h.data[i + 3] = s[3]))
: ((h.data[i] = e[0]),
  (h.data[i + 1] = e[1]),
  (h.data[i + 2] = e[2]),
  (h.data[i + 3] = e[3])),
(i += 4);
}
return h;
}),
(s.prototype.CleanBorderPixels = function() {
for (let t = 0; t < this.width; t++)
(this.data[t] = 0), (this.data[(this.height - 1) * this.width + t] = 0);
for (let t = 1; t < this.height - 2; t++)
(this.data[t * this.width] = 0),
(this.data[t * this.width + (this.width - 1)] = 0);
}),
(s.prototype.thin = function() {
let t = this.width - 2;
for (let i = 1; i < this.height - 1; i++) {
t += 2;
for (let i = 1; i < this.width - 1; i++) {
if ((t++, 0 == (1 & this.data[t]))) continue;
const i = this.getCurrentNeighborhood(this.data, t);
((0 == (7 & i) && 112 == (112 & i)) ||
(0 == (14 & i) && 160 == (160 & i)) ||
(0 == (28 & i) && 193 == (193 & i)) ||
(0 == (56 & i) && 130 == (130 & i)) ||
(0 == (112 & i) && 7 == (7 & i)) ||
(0 == (224 & i) && 10 == (10 & i)) ||
(0 == (193 & i) && 28 == (28 & i)) ||
(0 == (131 & i) && 40 == (40 & i))) &&
(this.data[t] = 0);
}
}
return this.data;
}),
(s.prototype.skeletonizeEckhardtMaderlechner93 = function(t, i, h) {
const e = this.width * this.height,
s = new Array(this.width * this.height),
a = new Array(this.width * this.height),
n = new Array(this.width * this.height),
o = new Array(this.width * this.height),
r = new Array(this.width * this.height),
d = new Array(this.width * this.height),
w = new Array(this.width * this.height),
g = new Array(this.width * this.height);
let f = !0,
c = 0;
const l = this.width + 1,
u = e - this.width - 1;
for (; f && c < t; ) {
f = !1;
for (let t = l; t < u; t++)
(a[t] = this.getNbStrongNeighbors(this.data, t)),
(n[t] = a[t] + this.getNbNoStrongNeighbors(this.data, t)),
this.data[t]
? 4 == a[t]
  ? ((s[t] = 2), (g[t] = 1))
  : ((s[t] = 1), (g[t] = 2))
: (s[t] = 0);
for (let t = l; t < u; t++)
this.data[t]
? (o[t] =
  1 == s[t] &&
  (2 == s[t + 1] ||
  2 == s[t - 1] ||
  2 == s[t + this.width] ||
  2 == s[t - this.width]))
: (o[t] = !1),
o[t] ? ((o[t] = 1), (g[t] = 3)) : (o[t] = 0);
for (let t = l; t < u; ++t) {
if (this.data[t] && 1 == s[t]) {
let i = 0 != (1 & this.data[t + 1]),
h = 0 != (1 & this.data[t - this.width + 1]),
e = 0 != (1 & this.data[t - this.width]),
a = 0 != (1 & this.data[t - this.width - 1]),
n = 0 != (1 & this.data[t - 1]),
o = 0 != (1 & this.data[t + this.width - 1]),
r = 0 != (1 & this.data[t + this.width]),
w = 0 != (1 & this.data[t + this.width + 1]);
const g =
(1 - i) * h +
(1 - h) * e +
(1 - e) * a +
(1 - a) * n +
(1 - n) * o +
(1 - o) * r +
(1 - r) * w +
(1 - w) * i,
f = i + h + e + a + n + o + r + w,
c = 1 == g || (0 == g && 8 == f);
d[t] = 1 == s[t] && c && (i || e || n || r);
} else d[t] = !1;
d[t] && (g[t] = 4);
}
for (let t = l; t < u; ++t) {
if (this.data[t]) {
const i = 2 == s[t + 1] && !this.data[t - 1],
h = 2 == s[t - 1] && !this.data[t + 1],
e = 2 == s[t + this.width] && !this.data[t - this.width],
a = 2 == s[t - this.width] && !this.data[t + this.width];
r[t] = o[t] && (i || h || e || a);
} else r[t] = !1;
r[t] && (g[t] = 5);
}
for (let t = 0; t < e; ++t)
this.data[t]
? d[t] && r[t]
  ? ((w[t] = 0), (g[t] = 6), (f = !0))
  : 0 == n[t]
  ? (w[t] = 0)
  : i.data[t] < h && 1 == n[t]
  ? ((w[t] = 0), (f = !0))
  : (w[t] = 1)
: ((w[t] = 0), (g[t] = 0));
for (let t = 0; t < w.length; t++) this.data[t] = w[t];
++c;
}
}),
(s.prototype.getCurrentNeighborhood = function(t, i) {
return (
((1 & t[i - 1]) << 7) |
((1 & t[i + 1]) << 3) |
((1 & t[i + this.width]) << 5) |
((1 & t[i - this.width]) << 1) |
(1 & t[i - (this.width + 1)]) |
((1 & t[i - (this.width - 1)]) << 2) |
((1 & t[i + (this.width - 1)]) << 6) |
((1 & t[i + (this.width + 1)]) << 4)
);
}),
(s.prototype.nbNeighbours = function(t) {
return (
(1 & t) +
((t >> 1) & 1) +
((t >> 2) & 1) +
((t >> 3) & 1) +
((t >> 4) & 1) +
((t >> 5) & 1) +
((t >> 6) & 1) +
((t >> 7) & 1)
);
}),
(s.prototype.getNbStrongNeighbors = function(t, i) {
return t[i - 1] + t[i + 1] + t[i - this.width] + t[i + this.width];
}),
(s.prototype.getNbNoStrongNeighbors = function(t, i) {
return (
t[i - 1 - this.width] +
t[i - 1 + this.width] +
t[i + 1 - this.width] +
t[i + 1 + this.width]
);
}),
(s.prototype.isInnerBoundaryPixel = function(t, i) {
return (
(1 == t[i] && 2 == t[i - 1]) ||
2 == t[i + 1] ||
2 == t[i - this.width] ||
2 == t[i + this.width]
);
}),
(s.prototype.isSimpleBoundaryPixel = function(t, i) {
let h = 0 != (1 & t[i + 1]),
e = 0 != (1 & t[i - this.width + 1]),
s = 0 != (1 & t[i - this.width]),
a = 0 != (1 & t[i - this.width - 1]),
n = 0 != (1 & t[i - 1]),
o = 0 != (1 & t[i + this.width - 1]),
r = 0 != (1 & t[i + this.width]),
d = 0 != (1 & t[i + this.width + 1]);
const w =
(1 - h) * e +
(1 - e) * s +
(1 - s) * a +
(1 - a) * n +
(1 - n) * o +
(1 - o) * r +
(1 - r) * d +
(1 - d) * h;
return (
(1 == w || (0 == w && 8 == h + e + s + a + n + o + r + d)) && (h || s || n || r)
);
});
var a = s,
n = function(t, i, h) {
(this.position = t), (this.weight = i), (this.neighbors = h);
};
(n.prototype.constructor = n),
(n.prototype.getPosition = function() {
return this.position;
}),
(n.prototype.getWeight = function() {
return this.weight;
}),
(n.prototype.getNeighbors = function() {
return this.neighbors;
}),
(n.prototype.setPosition = function(t) {
this.position = t;
}),
(n.prototype.setWeight = function(t) {
this.weight = t;
}),
(n.prototype.setNeighbors = function(t) {
this.neighbors = t;
});
var o = n,
r = function(t, i) {
(this.x = t), (this.y = i);
},
d = function(t, i) {
(this.skelImg = t), (this.distImg = i);
};
(d.prototype.constructor = d),
(d.prototype.buildHierarchy = function() {
const t = this.skelImg.width * this.skelImg.height;
let i,
h = new Array(t),
e = this._findFirstPixelWithNeighbors(this.skelImg, this.distImg, h);
if (e < t) {
const t = e % this.skelImg.width,
s = Math.round(e / this.skelImg.width);
(i = new o(new r(t + 0.5, s + 0.5), this.distImg.data[e], new Map())),
(h[e] = i),
this._recHierarchy(i, e, this.skelImg, this.distImg, h);
}
return console.log(i), i;
}),
(d.prototype._findFirstPixelWithNeighbors = function(t, i, h) {
const e = t.width * t.height;
let s;
for (s = 0; s < e; s++)
if (1 & t.data[s]) {
if (0 != t.getCurrentNeighborhood(t.data, s)) break;
t.data[s] = 0;
}
return s;
}),
(d.prototype._addNeighbors = function(t, i, h, e, s, a) {
const n = h % e,
d = Math.round(h / e);
let w = 0;
if (1 & i) {
if (!a[h - e - 1]) {
const t = new o(new r(n - 1 + 0.5, d - 1 + 0.5), s[h - e - 1], new Map());
(a[h - e - 1] = t), w++;
}
t.neighbors.set(h - e - 1, a[h - e - 1]);
}
if (2 & i) {
if (!a[h - e]) {
const t = new o(new r(n + 0.5, d - 1 + 0.5), s[h - e], new Map());
(a[h - e] = t), w++;
}
t.neighbors.set(h - e, a[h - e]);
}
if (4 & i) {
if (!a[h - e + 1]) {
const t = new o(new r(n + 1 + 0.5, d - 1 + 0.5), s[h - e + 1], new Map());
(a[h - e + 1] = t), w++;
}
t.neighbors.set(h - e + 1, a[h - e + 1]);
}
if (8 & i) {
if (!a[h + 1]) {
const t = new o(new r(n + 1 + 0.5, d + 0.5), s[h + 1], new Map());
(a[h + 1] = t), w++;
}
t.neighbors.set(h + 1, a[h + 1]);
}
if (16 & i) {
if (!a[h + e + 1]) {
const t = new o(new r(n + 1 + 0.5, d + 1 + 0.5), s[h + e + 1], new Map());
(a[h + e + 1] = t), w++;
}
t.neighbors.set(h + e + 1, a[h + e + 1]);
}
if (32 & i) {
if (!a[h + e]) {
const t = new o(new r(n + 0.5, d + 1 + 0.5), s[h + e], new Map());
(a[h + e] = t), w++;
}
t.neighbors.set(h + e, a[h + e]);
}
if (64 & i) {
if (!a[h + e - 1]) {
const t = new o(new r(n - 1 + 0.5, d + 1 + 0.5), s[h + e - 1], new Map());
(a[h + e - 1] = t), w++;
}
t.neighbors.set(h + e - 1, a[h + e - 1]);
}
if (128 & i) {
if (!a[h - 1]) {
const t = new o(new r(n - 1 + 0.5, d + 0.5), s[h - 1], new Map());
(a[h - 1] = t), w++;
}
t.neighbors.set(h - 1, a[h - 1]);
}
return w;
}),
(d.prototype._recHierarchy = function(t, i, h, e, s) {
const a = h.getCurrentNeighborhood(h.data, i);
if (this._addNeighbors(t, a, i, h.width, e.data, s))
for (let [i, a] of t.getNeighbors()) this._recHierarchy(a, i, h, e, s);
});
var w = d,
g = {
skeletonize: function(t) {
var h = new i(t),
s = new e(3, 4, h, 0),
n = new a(h, 0, 2e3, s);
return {
skeleton: new w(n, s).buildHierarchy(),
binaryImg: h,
distImg: s,
skelImg: n
};
},
displaySkeleton: function(t) {
const i = new Uint8ClampedArray(t.width * t.height * 4);
let h = 0;
for (let i = 0; i < t.width * t.height; i++) h = t.data[i] > h ? t.data[i] : h;
for (let h = 0, e = 0; h < t.height; h++)
for (let s = 0; s < t.width; s++) {
let a = h * t.width + s;
1 === t.data[a]
? ((i[e] = 255), (i[e + 1] = 0), (i[e + 2] = 0), (i[e + 3] = 255))
: ((i[e] = 255), (i[e + 1] = 255), (i[e + 2] = 255), (i[e + 3] = 255)),
(e += 4);
}
return new ImageData(i, t.width, t.height);
}
};
return g;
});
