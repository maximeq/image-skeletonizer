!(function(t, e) {
"object" == typeof exports && "undefined" != typeof module
? (module.exports = e())
: "function" == typeof define && define.amd
? define(e)
: (t.ImageSkeletonizer = e());
})(this, function() {
"use strict";
var t = function(t, e) {
(this.tolerance = void 0 !== e ? e : 12),
(this.width = t.width),
(this.height = t.height),
(this.data = new Uint8Array(t.width * t.height)),
this._buildBinaryImage(t, this.tolerance);
};
(t.prototype.constructor = t),
(t.prototype.getIndex = function(t, e) {
return e * this.width + t;
}),
(t.prototype.getValue = function(t, e) {
return this.data[this.getIndex(t, e)];
}),
(t.prototype._buildBinaryImage = function(t, e) {
for (var i = this.width * this.height, h = 0; h < i; h++) {
var o = 4 * h;
t.data[o] < 125 && t.data[o + 1] < 125 && t.data[o + 2] < 125
? (this.data[h] = 1)
: (this.data[h] = 0);
}
});
var e = t,
i = function(t, i, h, o) {
if (!(h instanceof e))
throw "IntDistanceImage Error : source must be an instance of BinaryImage";
(this.coeff = t),
(this.width = h.width),
(this.height = h.height),
(this.data = new Array(h.width * h.height)),
this._buildDistanceImage(t, i, h, o);
};
(i.prototype.constructor = i),
(i.prototype.rebuild = function(t, e, i, h) {
(this.coeff = t), this._buildDistanceImage(t, e, i, h, this.data);
}),
(i.prototype.getCoeff = function() {
return this.coeff;
}),
(i.prototype.getIndex = function(t, e) {
return e * this.width + t;
}),
(i.prototype.getValue = function(t, e) {
return this.data[this.getIndex(t, e)];
}),
(i.prototype.getIndexValue = function(t) {
return this.data[t];
}),
(i.prototype.getXFromIndex = function(t) {
return t % this.width;
}),
(i.prototype.getYFromIndex = function(t) {
return Math.floor(t / this.width);
}),
(i.prototype._buildDistanceImage = function(t, e, i, h) {
const o = i.width,
n = i.height;
for (let t = 0; t < o; ++t) this.data[t] = 0;
for (let s = 1; s < n - 1; ++s) {
this.data[s * o] = 0;
for (let n = 1; n < o - 1; ++n) {
let o = this.getIndex(n, s);
this.data[o] = 0;
let r = 0;
if (i.data[o] != h) {
let i = this.getIndex(n - 1, s - 1),
h = this.getIndex(n, s - 1),
a = this.getIndex(n - 1, s),
g = this.getIndex(n + 1, s - 1);
(r = Math.min(this.data[i] + e, this.data[h] + t)),
(r = Math.min(r, this.data[a] + t)),
(r = Math.min(r, this.data[g] + e)),
(this.data[o] = r);
}
}
this.data[this.getIndex(o - 1, s)] = 0;
}
for (let t = 0; t < o; ++t) this.data[this.getIndex(t, n - 1)] = 0;
for (let s = n - 2; s > 0; --s)
for (let n = o - 2; n > 0; --n) {
let o = this.getIndex(n, s),
r = this.data[o];
if (i.data[o] != h) {
let i = this.getIndex(n + 1, s + 1),
h = this.getIndex(n, s + 1),
a = this.getIndex(n - 1, s + 1),
g = this.getIndex(n + 1, s);
(r = Math.min(r, this.data[i] + e)),
(r = Math.min(r, this.data[h] + t)),
(r = Math.min(r, this.data[a] + e)),
(this.data[o] = Math.min(r, this.data[g] + t));
}
}
}),
(i.prototype.getImageData = function(t) {
var e = new ImageData(this.width, this.height);
let i = 0;
for (let t = 0; t < this.width * this.height; t++)
i = this.data[t] > i ? this.data[t] : i;
for (let t = 0, h = 0, o = 0; t < this.height; t++)
for (let n = 0; n < this.width; n++) {
let s = t * this.width + n;
this.data[s] > 3
? ((o = (255 * this.data[s]) / i),
  (e.data[h] = o),
  (e.data[h + 1] = o),
  (e.data[h + 2] = o),
  (e.data[h + 3] = 255))
: ((e.data[h] = 255),
  (e.data[h + 1] = 255),
  (e.data[h + 2] = 255),
  (e.data[h + 3] = 255)),
(h += 4);
}
return e;
});
var h = i,
o = function(t, e) {
(this.x = t), (this.y = e);
};
(o.prototype.distanceToOrigin = function(t) {
var e = this.x,
i = this.y;
return Math.sqrt(e * e + i * i);
}),
(o.prototype.distanceTo = function(t) {
var e = this.x - t.x,
i = this.y - t.y;
return Math.sqrt(e * e + i * i);
}),
(o.prototype.barycenter = function(t, e, i, h) {
var o = h / (i + h);
return (
(this.x = (1 - o) * t.x + o * e.x), (this.y = (1 - o) * t.y + o * e.y), this
);
});
var n = o,
s = function(t, e, i, h) {
(this.width = t.width),
(this.height = t.height),
(this.data = new Array(this.width * this.height));
for (let i = 0; i < this.width * this.height; i++)
t.data[i] != e ? (this.data[i] = 1) : (this.data[i] = 0);
let o = 0;
for (let t = 0; t < h.width * h.height; t++) o = h.data[t] > o ? h.data[t] : o;
this.CleanBorderPixels(),
this.skeletonizeEckhardtMaderlechner93(i, h, 0.8 * o),
this.CleanBorderPixels(),
this.thin();
};
(s.prototype.constructor = s),
(s.prototype.getIndex = function(t, e) {
return e * this.width + t;
}),
(s.prototype.getXFromIndex = function(t) {
return t % this.width;
}),
(s.prototype.getYFromIndex = function(t) {
return Math.floor(t / this.width);
}),
(s.prototype.getImageData = function(t, e) {
var i = new ImageData(this.width, this.height),
h = t || [255, 255, 255, 255],
o = e || [255, 0, 0, 255];
let n = 0;
for (let t = 0; t < this.width * this.height; t++)
n = this.data[t] > n ? this.data[t] : n;
for (let t = 0, e = 0; t < this.height; t++)
for (let n = 0; n < this.width; n++) {
let s = t * this.width + n;
1 === this.data[s]
? ((i.data[e] = o[0]),
  (i.data[e + 1] = o[1]),
  (i.data[e + 2] = o[2]),
  (i.data[e + 3] = o[3]))
: ((i.data[e] = h[0]),
  (i.data[e + 1] = h[1]),
  (i.data[e + 2] = h[2]),
  (i.data[e + 3] = h[3])),
(e += 4);
}
return i;
}),
(s.prototype.CleanBorderPixels = function() {
for (let t = 0; t < this.width; t++)
(this.data[t] = 0), (this.data[(this.height - 1) * this.width + t] = 0);
for (let t = 1; t < this.height - 2; t++)
(this.data[t * this.width] = 0),
(this.data[t * this.width + (this.width - 1)] = 0);
}),
(s.prototype.thin = function() {
let t = this.width - 2;
for (let e = 1; e < this.height - 1; e++) {
t += 2;
for (let e = 1; e < this.width - 1; e++) {
if ((t++, 0 == (1 & this.data[t]))) continue;
const e = this.getCurrentNeighborhood(t);
((0 == (7 & e) && 112 == (112 & e)) ||
(0 == (14 & e) && 160 == (160 & e)) ||
(0 == (28 & e) && 193 == (193 & e)) ||
(0 == (56 & e) && 130 == (130 & e)) ||
(0 == (112 & e) && 7 == (7 & e)) ||
(0 == (224 & e) && 10 == (10 & e)) ||
(0 == (193 & e) && 28 == (28 & e)) ||
(0 == (131 & e) && 40 == (40 & e))) &&
(this.data[t] = 0);
}
}
return this.data;
}),
(s.prototype.skeletonizeEckhardtMaderlechner93 = function(t, e, i) {
const h = this.width * this.height,
o = new Array(this.width * this.height),
n = new Array(this.width * this.height),
s = new Array(this.width * this.height),
r = new Array(this.width * this.height),
a = new Array(this.width * this.height),
g = new Array(this.width * this.height),
d = new Array(this.width * this.height),
f = new Array(this.width * this.height);
let u = !0,
y = 0;
const c = this.width + 1,
l = h - this.width - 1;
for (; u && y < t; ) {
u = !1;
for (let t = c; t < l; t++)
(n[t] = this.getNbStrongNeighbors(this.data, t)),
(s[t] = n[t] + this.getNbNoStrongNeighbors(this.data, t)),
this.data[t]
? 4 == n[t]
  ? ((o[t] = 2), (f[t] = 1))
  : ((o[t] = 1), (f[t] = 2))
: (o[t] = 0);
for (let t = c; t < l; t++)
this.data[t]
? (r[t] =
  1 == o[t] &&
  (2 == o[t + 1] ||
  2 == o[t - 1] ||
  2 == o[t + this.width] ||
  2 == o[t - this.width]))
: (r[t] = !1),
r[t] ? ((r[t] = 1), (f[t] = 3)) : (r[t] = 0);
for (let t = c; t < l; ++t) {
if (this.data[t] && 1 == o[t]) {
let e = 0 != (1 & this.data[t + 1]),
i = 0 != (1 & this.data[t - this.width + 1]),
h = 0 != (1 & this.data[t - this.width]),
n = 0 != (1 & this.data[t - this.width - 1]),
s = 0 != (1 & this.data[t - 1]),
r = 0 != (1 & this.data[t + this.width - 1]),
a = 0 != (1 & this.data[t + this.width]),
d = 0 != (1 & this.data[t + this.width + 1]);
const f =
(1 - e) * i +
(1 - i) * h +
(1 - h) * n +
(1 - n) * s +
(1 - s) * r +
(1 - r) * a +
(1 - a) * d +
(1 - d) * e,
u = e + i + h + n + s + r + a + d,
y = 1 == f || (0 == f && 8 == u);
g[t] = 1 == o[t] && y && (e || h || s || a);
} else g[t] = !1;
g[t] && (f[t] = 4);
}
for (let t = c; t < l; ++t) {
if (this.data[t]) {
const e = 2 == o[t + 1] && !this.data[t - 1],
i = 2 == o[t - 1] && !this.data[t + 1],
h = 2 == o[t + this.width] && !this.data[t - this.width],
n = 2 == o[t - this.width] && !this.data[t + this.width];
a[t] = r[t] && (e || i || h || n);
} else a[t] = !1;
a[t] && (f[t] = 5);
}
for (let t = 0; t < h; ++t)
this.data[t]
? g[t] && a[t]
  ? ((d[t] = 0), (f[t] = 6), (u = !0))
  : 0 == s[t]
  ? (d[t] = 0)
  : e.data[t] < i && 1 == s[t]
  ? ((d[t] = 0), (u = !0))
  : (d[t] = 1)
: ((d[t] = 0), (f[t] = 0));
for (let t = 0; t < d.length; t++) this.data[t] = d[t];
++y;
}
}),
(s.prototype.getCurrentNeighborhood = function(t) {
var e = this.data;
return (
((1 & e[t - 1]) << 7) |
((1 & e[t + 1]) << 3) |
((1 & e[t + this.width]) << 5) |
((1 & e[t - this.width]) << 1) |
(1 & e[t - (this.width + 1)]) |
((1 & e[t - (this.width - 1)]) << 2) |
((1 & e[t + (this.width - 1)]) << 6) |
((1 & e[t + (this.width + 1)]) << 4)
);
}),
(s.prototype.nbNeighbours = function(t) {
return (
(1 & t) +
((t >> 1) & 1) +
((t >> 2) & 1) +
((t >> 3) & 1) +
((t >> 4) & 1) +
((t >> 5) & 1) +
((t >> 6) & 1) +
((t >> 7) & 1)
);
}),
(s.prototype.getNbStrongNeighbors = function(t, e) {
return t[e - 1] + t[e + 1] + t[e - this.width] + t[e + this.width];
}),
(s.prototype.getNbNoStrongNeighbors = function(t, e) {
return (
t[e - 1 - this.width] +
t[e - 1 + this.width] +
t[e + 1 - this.width] +
t[e + 1 + this.width]
);
}),
(s.prototype.isInnerBoundaryPixel = function(t, e) {
return (
(1 == t[e] && 2 == t[e - 1]) ||
2 == t[e + 1] ||
2 == t[e - this.width] ||
2 == t[e + this.width]
);
}),
(s.prototype.isSimpleBoundaryPixel = function(t, e) {
let i = 0 != (1 & t[e + 1]),
h = 0 != (1 & t[e - this.width + 1]),
o = 0 != (1 & t[e - this.width]),
n = 0 != (1 & t[e - this.width - 1]),
s = 0 != (1 & t[e - 1]),
r = 0 != (1 & t[e + this.width - 1]),
a = 0 != (1 & t[e + this.width]),
g = 0 != (1 & t[e + this.width + 1]);
const d =
(1 - i) * h +
(1 - h) * o +
(1 - o) * n +
(1 - n) * s +
(1 - s) * r +
(1 - r) * a +
(1 - a) * g +
(1 - g) * i;
return (
(1 == d || (0 == d && 8 == i + h + o + n + s + r + a + g)) && (i || o || s || a)
);
});
var r = s,
a = function(t, e) {
(this.position = t), (this.weight = e), (this.neighbors = new Map());
};
(a.computeKey = function(t, e) {
return Math.floor(t) + ";" + Math.floor(e);
}),
(a.getXYFromKey = function(t) {
var e = t.split(";");
return (e[0] = parseInt(e[0])), (e[1] = parseInt(e[1])), e;
}),
(a.prototype.constructor = a),
(a.prototype.getKey = function() {
return a.computeKey(this.position.x, this.position.y);
}),
(a.prototype.getPosition = function() {
return this.position;
}),
(a.prototype.getWeight = function() {
return this.weight;
}),
(a.prototype.getNeighbors = function() {
return this.neighbors;
}),
(a.prototype.setPosition = function(t) {
this.position = t;
}),
(a.prototype.setWeight = function(t) {
this.weight = t;
}),
(a.prototype.setNeighbors = function(t) {
this.neighbors = t;
}),
(a.prototype.addNeighbor = function(t) {
this.neighbors.set(t.getKey(), t), t.neighbors.set(this.getKey(), this);
}),
(a.prototype.removeNeighbor = function(t) {
this.neighbors.delete(t.getKey()), t.neighbors.delete(this.getKey());
}),
(a.prototype.hasNeighbor = function(t) {
return this.neighbors.has(t.getKey());
});
var g = a,
d = function(t, e) {
(this.x = t || 0), (this.y = e || 0);
};
(d.prototype.length = function(t) {
var e = this.x,
i = this.y;
return Math.sqrt(e * e + i * i);
}),
(d.prototype.subPoints = function(t, e) {
return (this.x = t.x - e.x), (this.y = t.y - e.y), this;
}),
(d.prototype.angle = function() {
var t = Math.atan2(this.y, this.x);
return t < 0 && (t += 2 * Math.PI), t;
});
var f = d,
u = function(t, e) {
(this.skelImg = t), (this.distImg = e);
};
(u.prototype.constructor = u),
(u.prototype.buildHierarchy = function(t) {
((t = t || {}).angle = t.angle || Math.PI / 13),
(t.weightFactor = t.weightFactor || 1.25);
const e = this.skelImg.width * this.skelImg.height;
let i = {},
h = [],
o = this._findNextPixelWithNeighbors(0);
for (; o < e; ) {
const t = this.skelImg.getXFromIndex(o),
e = this.skelImg.getYFromIndex(o);
var s = g.computeKey(t + 0.5, e + 0.5);
void 0 === i[s] &&
((i[s] = new g(
new n(t + 0.5, e + 0.5),
this.distImg.data[o] / this.distImg.getCoeff()
)),
h.push(i[s]),
this._recHierarchy(i[s], i)),
(o = this._findNextPixelWithNeighbors(o + 1));
}
return this._simplifyHierarchy(h, t.angle, t.weightFactor);
}),
(u.prototype._simplifyHierarchy = function(t, e, i) {
if (i < 1)
throw "weight_factor must be greater than 1 as it compares weight_max and weight_factor*weight_min";
for (
var h = function(t, o) {
for (
var n = new f(),
r = o,
a = new f(),
g = r.getNeighbors().size,
d = !0,
u = !0,
y = null,
c = 0;
2 === g && d && u && !s[r.getKey()];

) {
var l = r.getNeighbors().keys();
(y = r),
(r = r.getNeighbors().get(l.next().value)) === t &&
(r = y.getNeighbors().get(l.next().value));
c < 3 && ((a.x += r.getPosition().x), (a.y += r.getPosition().y)),
2 === c &&
((a.x = (a.x - 3 * t.getPosition().x) / 3),
(a.y = (a.y - 3 * t.getPosition().y) / 3)),
c++,
n.subPoints(r.getPosition(), t.getPosition());
var p = n.angle() - a.angle();
if ((Math.abs(p) < e || c < 3 || (d = !1), c >= 3)) {
var w = t.getWeight() / r.getWeight();
w < 1 && (w = 1 / w), w > i && (u = !1);
}
d && u && (t.removeNeighbor(y), r.removeNeighbor(y), t.addNeighbor(r)),
(s[y.getKey()] = !0),
(g = r.getNeighbors().size);
}
if (!s[r.getKey()])
if (1 === g)
(d && u) || (y && y.removeNeighbor(r)),
0 === c && t.removeNeighbor(r),
(s[r.getKey()] = !0);
else if (2 === g) h(y, r), (s[y.getKey()] = !0);
else {
var x = [];
if (
(r.getNeighbors().forEach(function(e, i, h) {
e !== y && e !== t && x.push(e);
}),
!d || !u)
) {
y.removeNeighbor(r);
for (var I = 0; I < x.length; ++I) r.removeNeighbor[x[I]], y.addNeighbor[x[I]];
r = y;
}
s[r.getKey()] = !0;
var m = new Map();
for (I = 0; I < x.length; ++I) {
for (var v = I + 1; v < x.length; ++v) x[I].removeNeighbor(x[v]);
x[I].getNeighbors().forEach(function(t, e, i) {
m.set(e, t);
});
}
m.delete(r.getKey());
var b = new f();
m.forEach(function(t, e, i) {
for (var h = 0, o = 0; o < x.length; ++o) t.hasNeighbor(x[o]) && h++;
if (h > 1)
for (o = 0; o < x.length; ++o)
t.hasNeighbor(x[o]) &&
(b.subPoints(t.getPosition(), x[o].getPosition()),
b.length() > 1 && t.removeNeighbor(x[o]));
});
for (I = 0; I < x.length; ++I) h(r, x[I]);
}
},
o = 0;
o < t.length;
++o
) {
var n = t[o],
s = {};
s[n.getKey()] = !0;
n.getNeighbors().get(
n
.getNeighbors()
.keys()
.next().value
);
if (n.getNeighbors().size > 1) throw "Hoho... Should not happen";
h(
n,
n.getNeighbors().get(
n
.getNeighbors()
.keys()
.next().value
)
);
}
return t;
}),
(u.prototype._findNextPixelWithNeighbors = function(t) {
const e = this.skelImg.width * this.skelImg.height;
let i = t;
for (i = t; i < e; i++)
if (1 & this.skelImg.data[i]) {
if (0 != this.skelImg.getCurrentNeighborhood(i)) break;
this.skelImg.data[i] = 0;
}
return i;
}),
(u.prototype._checkAndCreate = function(t, e, i, h) {
var o = g.computeKey(t + 0.5, e + 0.5),
s = !1;
return (
void 0 === h[o] &&
((h[o] = new g(
new n(t + 0.5, e + 0.5),
this.distImg.getValue(t, e) / this.distImg.getCoeff()
)),
(s = !0)),
i.neighbors.set(o, h[o]),
s
);
}),
(u.prototype._addNeighbors = function(t, e, i) {
this.skelImg.width;
const h = Math.floor(t.position.x),
o = Math.floor(t.position.y);
let n = 0;
return (
1 & e && (n += this._checkAndCreate(h - 1, o - 1, t, i) ? 1 : 0),
2 & e && (n += this._checkAndCreate(h, o - 1, t, i) ? 1 : 0),
4 & e && (n += this._checkAndCreate(h + 1, o - 1, t, i) ? 1 : 0),
8 & e && (n += this._checkAndCreate(h + 1, o, t, i) ? 1 : 0),
16 & e && (n += this._checkAndCreate(h + 1, o + 1, t, i) ? 1 : 0),
32 & e && (n += this._checkAndCreate(h, o + 1, t, i) ? 1 : 0),
64 & e && (n += this._checkAndCreate(h - 1, o + 1, t, i) ? 1 : 0),
128 & e && (n += this._checkAndCreate(h - 1, o, t, i) ? 1 : 0),
n
);
}),
(u.prototype._addNeighborsOLD = function(t, e, i, h) {
const o = this.skelImg.width,
s = i % o,
r = Math.round(i / o);
let a = 0;
if (1 & e) {
if (void 0 === h[i - o - 1]) {
const t = new g(
new n(s - 1 + 0.5, r - 1 + 0.5),
this.distImg.getIndexValue(i - o - 1)
);
(h[i - o - 1] = t), a++;
}
t.neighbors.set(i - o - 1, h[i - o - 1]);
}
if (2 & e) {
if (void 0 === h[i - o]) {
const t = new g(new n(s + 0.5, r - 1 + 0.5), this.distImg.getIndexValue(i - o));
(h[i - o] = t), a++;
}
t.neighbors.set(i - o, h[i - o]);
}
if (4 & e) {
if (void 0 === h[i - o + 1]) {
const t = new g(
new n(s + 1 + 0.5, r - 1 + 0.5),
this.distImg.getIndexValue(i - o + 1)
);
(h[i - o + 1] = t), a++;
}
t.neighbors.set(i - o + 1, h[i - o + 1]);
}
if (8 & e) {
if (void 0 === h[i + 1]) {
const t = new g(new n(s + 1 + 0.5, r + 0.5), this.distImg.getIndexValue(i + 1));
(h[i + 1] = t), a++;
}
t.neighbors.set(i + 1, h[i + 1]);
}
if (16 & e) {
if (void 0 === h[i + o + 1]) {
const t = new g(
new n(s + 1 + 0.5, r + 1 + 0.5),
this.distImg.getIndexValue(i + o + 1)
);
(h[i + o + 1] = t), a++;
}
t.neighbors.set(i + o + 1, h[i + o + 1]);
}
if (32 & e) {
if (void 0 === h[i + o]) {
const t = new g(new n(s + 0.5, r + 1 + 0.5), this.distImg.getIndexValue(i + o));
(h[i + o] = t), a++;
}
t.neighbors.set(i + o, h[i + o]);
}
if (64 & e) {
if (void 0 === h[i + o - 1]) {
const t = new g(
new n(s - 1 + 0.5, r + 1 + 0.5),
this.distImg.getIndexValue(i + o - 1)
);
(h[i + o - 1] = t), a++;
}
t.neighbors.set(i + o - 1, h[i + o - 1]);
}
if (128 & e) {
if (void 0 === h[i - 1]) {
const t = new g(new n(s - 1 + 0.5, r + 0.5), this.distImg.getIndexValue(i - 1));
(h[i - 1] = t), a++;
}
t.neighbors.set(i - 1, h[i - 1]);
}
return a;
}),
(u.prototype._recHierarchy = function(t, e) {
const i = this.skelImg.getCurrentNeighborhood(
this.skelImg.getIndex(Math.floor(t.position.x), Math.floor(t.position.y))
);
if (this._addNeighbors(t, i, e))
for (let [i, h] of t.getNeighbors()) this._recHierarchy(h, e);
});
var y,
c,
l,
p = u,
w = ((y = new f()),
(c = new f()),
(l = new n()),
function(t, e, i, h, o) {
(y.x = e.x - t.x), (y.y = e.y - t.y);
var n = y.length();
(y.x = y.x / n), (y.y = y.y / n), c.subPoints(o, t);
var s = c.length(),
r = s * s,
a = c.x * y.x + c.y * y.y,
g = (a + (-Math.sqrt(Math.max(0, r - a * a)) / n) * (i - h)) / n;
return (
g > 1 && (g = 1),
g < 0 && (g = 0),
(l.x = t.x),
(l.y = t.y),
(l.x += (e.x - l.x) * g),
(l.y += (e.y - l.y) * g),
(l.z += (e.z - l.z) * g),
(c.x = o.x - l.x),
(c.y = o.y - l.y),
c.length() - (g * h + (1 - g) * i)
);
}),
x = function(t) {
this.distImg = t;
};
(x.prototype.constructor = x),
(x.prototype.buildHierarchy = function() {
var t = this;
const e = this.distImg.width,
i = this.distImg.height;
for (var h = {}, o = {}, s = [], r = new Array(e * i), a = 0; a < r.length; ++a)
r[a] = !1;
for (
var d = function(i, h, o) {
for (
var s = i.position.x,
a = i.position.y,
g = i.getPosition(),
d = Math.ceil(i.weight),
f = h ? Math.ceil(h.getWeight()) : 0,
u = h ? h.getPosition() : null,
y = new n(0, 0),
c = {
min: {
x: h ? Math.min(g.x - d, u.x - f) : g.x - d,
y: h ? Math.min(g.y - d, u.y - f) : g.y - d
},
max: {
x: h ? Math.max(g.x + d, u.x + f) : g.x + d,
y: h ? Math.max(g.y + d, u.y + f) : g.y + d
}
},
l = c.min.x;
l < c.max.x;
l++
)
for (var p = c.min.y; p < c.max.y; p++) {
(y.x = l), (y.y = p);
var x = h
? w(i.getPosition(), h.getPosition(), d, Math.ceil(h.weight), y)
: (l - s) * (l - s) + (p - a) * (p - a);
if (h ? x <= 0 : x <= d * d) (r[(N = p * e + l)] = !0), delete o[N];
}
for (
var I = 2 * Math.PI * (i.weight + 1), m = Math.round(I), v = 0;
v < m;
++v
) {
var b = (2 * v * Math.PI) / m,
N = ((l = Math.round(i.position.x + Math.cos(b) * (i.weight + 1))),
(p = Math.round(i.position.y + Math.sin(b) * (i.weight + 1))) * e + l),
M = t.distImg.getValue(l, p) / t.distImg.getCoeff();
!r[N] && M > 3 && (o[N] = i);
}
},
f = 0,
u = -1,
y = -1,
c = 0;
c < e;
++c
)
for (var l = 0; l < i; ++l) {
var p = this.distImg.getValue(c, l);
p > f && ((f = p), (u = c), (y = l));
}
var x = new g(new n(u, y), f / this.distImg.getCoeff());
(o[this.distImg.getIndex(u, y)] = x), s.push(x), d(x, null, h);
for (var I = 0, m = Object.keys(h); 0 !== m.length && I < 1e4; ) {
var v = -1,
b = 0;
for (a = 0; a < m.length; ++a) {
var N = parseInt(m[a]);
r[N]
? delete h[m[a]]
: this.distImg.getIndexValue(N) > b &&
  ((b = this.distImg.getIndexValue(N)), (v = N));
}
b /= this.distImg.getCoeff();
var M = new n(this.distImg.getXFromIndex(v), this.distImg.getYFromIndex(v)),
k = h[v],
P = {v: b, p: new n(M.x, M.y), idx: v};
(function() {
var e = k.getPosition().distanceTo(M),
i = new n(0, 0);
i.barycenter(M, k.getPosition(), 0.5, 0.5),
(i.x = Math.round(i.x)),
(i.y = Math.round(i.y));
var h = t.distImg.getValue(i.x, i.y) / t.distImg.getCoeff(),
o = new n(0, 0),
s = new n(M.x - k.getPosition().x, M.y - k.getPosition().y);
(s.x /= e), (s.y /= e);
for (
var r = new n(-s.y, s.x),
a = {v: h, p: new n(i.x, i.y), idx: v},
g = Math.max(k.getWeight() / 2, 3),
d = -g;
d <= g;
d++
) {
(o.x = Math.round(i.x + d * r.x)), (o.y = Math.round(i.y + d * r.y));
var f = t.distImg.getValue(o.x, o.y) / t.distImg.getCoeff();
f > a.v && f > h + 1.5 && ((a.v = f), (a.p.x = o.x), (a.p.y = o.y));
}
return (
(a.p.x !== i.x || a.p.y !== i.y) &&
((P.v = a.v),
(P.p.x = a.p.x),
(P.p.y = a.p.y),
(P.idx = t.distImg.getIndex(a.p.x, a.p.y)),
!0)
);
})() ||
(function() {
for (
var e = k.getPosition().distanceTo(M), i = new n(0, 0), h = 1;
h < e;
h += 1
) {
var o = h / e;
i.barycenter(M, k.getPosition(), 1 - o, o),
(i.x = Math.round(i.x)),
(i.y = Math.round(i.y));
var s = t.distImg.getValue(i.x, i.y) / t.distImg.getCoeff(),
r = h + b - s,
a = (1 - o) * b + o * k.weight;
r < 1 &&
s > a &&
((P.v = s),
(P.p.x = i.x),
(P.p.y = i.y),
(P.idx = t.distImg.getIndex(i.x, i.y)));
}
})();
var _ = new g(P.p, P.v);
_.neighbors.set(this.distImg.getIndex(k.position.x, k.position.y), k),
k.neighbors.set(this.distImg.getIndex(_.position.x, _.position.y), _),
(o[P.idx] = _),
s.push(_),
delete h[v],
delete h[P.idx],
d(_, k, h),
(m = Object.keys(h)),
I++;
}
return s;
});
var I = x,
m = {};
return (
(m.BinaryImage = e),
(m.IntDistanceImage = h),
(m.SkeletonImage = r),
(m.Skeletonizer = p),
(m.skeletonize = function(t, i, o) {
var n = new e(t),
s = new h(3, 4, n, 0),
a = new r(n, 0, 2e3, s);
return {
skeleton: new p(a, s).buildHierarchy({
angle: i || void 0,
weightFactor: o || void 0
}),
binaryImg: n,
distImg: s,
skelImg: a
};
}),
(m.skeletonizeQ = function(t) {
var i = new e(t),
o = new h(3, 4, i, 0);
return {skeleton: new I(o).buildHierarchy(), binaryImg: i, distImg: o};
}),
(m.drawHierarchyInImageData = function(t, e, i) {
for (
var h = e,
o = "capsule" === i,
s = new n(),
r = {},
a = [],
g = [],
d = function(t) {
var e = t.getKey();
void 0 === r[e] &&
((r[e] = t),
a.push(t),
t.getNeighbors().forEach(function(e, i, h) {
var o = e.getKey();
void 0 === r[o] && g.push([t, e]), d(e);
}));
},
f = 0;
f < t.length;
++f
)
d(t[f]);
for (var u = 0; u < h.width; ++u)
for (var y = 0; y < h.height; ++y) {
var c = 0;
if (((s.x = u + 0.5), (s.y = y + 0.5), o))
for (f = 0; f < g.length; ++f) {
var l = g[f][0],
p = g[f][1];
w(l.getPosition(), p.getPosition(), l.getWeight(), p.getWeight(), s) <= 0 &&
c++;
}
else
for (f = 0; f < a.length; ++f) {
var x = Math.floor(a[f].getPosition().x) + 0.5,
I = Math.floor(a[f].getPosition().y) + 0.5;
(s.x - x) * (s.x - x) + (s.y - I) * (s.y - I) <=
a[f].getWeight() * a[f].getWeight() && c++;
}
var m = 4 * (y * h.width + u);
h.data[m + 1] = (h.data[m + 1] + 255 * c) / (c + 1);
}
for (f = 0; f < a.length; ++f) {
var v = a[f];
m = 4 * (Math.floor(v.position.y) * h.width + Math.floor(v.position.x));
(h.data[m] = 255), (h.data[m + 1] = 0), (h.data[m + 2] = 0);
}
return h;
}),
(m.drawSkeletonInCanvas = function(t, e) {
for (
var i = e.getContext("2d"),
h = {},
o = [],
n = function(t) {
var e = t.position.x + ";" + t.position.y;
void 0 === h[e] &&
((h[e] = t),
o.push(t),
t.getNeighbors().forEach(function(t, e, i) {
n(t);
}));
},
s = 0;
s < t.length;
++s
)
n(t[s]);
for (s = 0; s < o.length; ++s) {
var r = o[s];
r.getNeighbors().forEach(function(t, e, h) {
(i.lineWidth = 1),
(i.strokeStyle = "#ff0000"),
i.beginPath(),
i.moveTo(r.position.x, r.position.y),
i.lineTo(t.position.x, t.position.y),
i.stroke(),
(i.fillStyle = "#0000ff"),
i.fillRect(r.position.x, r.position.y, 1, 1),
i.fillRect(t.position.x, t.position.y, 1, 1);
});
}
}),
m
);
});
